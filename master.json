{
  "source": {
    "README.md": {
      "path": "README.md",
      "content": "SFXZ\n====\n\nA recreation of sfxr. Wish me luck!\n",
      "mode": "100644",
      "type": "blob"
    },
    "demo.js": {
      "path": "demo.js",
      "content": "\nvar PARAMS;\nvar SOUND;\nvar SOUND_VOL = 0.25;\nvar SAMPLE_RATE = 44100;\nvar SAMPLE_SIZE = 8;\n\nParams.prototype.query = function () {\n  var result = \"\";\n  var that = this;\n  $.each(this, function (key,value) {\n    if (that.hasOwnProperty(key))\n      result += \"&\" + key + \"=\" + value;\n  });\n  return result.substring(1);\n};\n\nfunction gen(fx) {\n  PARAMS = new Params();\n  PARAMS.sound_vol = SOUND_VOL;\n  PARAMS.sample_rate = SAMPLE_RATE;\n  PARAMS.sample_size = SAMPLE_SIZE;\n  PARAMS[fx]();\n  $(\"#wav\").text(fx + \".wav\");\n  updateUi();\n  play();\n}\n\nfunction mut() {\n  PARAMS.mutate();\n  updateUi();\n  play();\n}\n\nfunction play(noregen) {\n  setTimeout(function () {\n    var audio = new Audio();\n    if (!noregen) {\n      SOUND = new SoundEffect(PARAMS).generate();\n      $(\"#file_size\").text(Math.round(SOUND.wav.length / 1024) + \"kB\");\n      $(\"#num_samples\").text(SOUND.header.subChunk2Size /\n                             (SOUND.header.bitsPerSample >> 3));\n      $(\"#clipping\").text(SOUND.clipping);\n    }\n    audio.src = SOUND.dataURI;\n    $(\"#wav\").attr(\"href\", SOUND.dataURI);\n    $(\"#sfx\").attr(\"href\", \"sfx.wav?\" + PARAMS.query());\n    audio.play();\n  }, 0);\n}\n\nfunction disenable() {\n  var duty = PARAMS.wave_type == SQUARE || PARAMS.wave_type == SAWTOOTH;\n  $(\"#p_duty\").slider(\"option\", \"disabled\", !duty);\n  $(\"#p_duty_ramp\").slider(\"option\", \"disabled\", !duty);\n}\n\nfunction updateUi() {\n  $.each(PARAMS, function (param, value) {\n    if (param == \"wave_type\") {\n      $(\"#shape input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else if (param == \"sample_rate\") {\n      $(\"#hz input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else if (param == \"sample_size\") {\n      $(\"#bits input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else {\n      var id = \"#\" + param;\n      $(id).slider(\"value\", 1000 * value);\n      $(id).each(function(){convert(this, PARAMS[this.id]);});\n    }\n  });\n  disenable();\n}\n\n\n$(function() {\n  $(\"#shape\").buttonset();\n  $(\"#hz\").buttonset();\n  $(\"#bits\").buttonset();\n  $(\"#shape input:radio\").change(function (event) {\n    PARAMS.wave_type = parseInt(event.target.value);\n    disenable();\n    play();\n  });\n  $(\"#hz input:radio\").change(function (event) {\n    SAMPLE_RATE = PARAMS.sample_rate = parseInt(event.target.value);\n    play();\n  });\n  $(\"#bits input:radio\").change(function (event) {\n    SAMPLE_SIZE = PARAMS.sample_size = parseInt(event.target.value);\n    play();\n  });\n  $(\"button\").button();\n  $(\".slider\").slider({\n    value: 1000,\n    min: 0,\n    max: 1000,\n    slide: function (event, ui) {\n      convert(event.target, ui.value / 1000.0);\n    },\n    change: function(event, ui) {\n      if (event.originalEvent) {\n        PARAMS[event.target.id] = ui.value / 1000.0;\n        convert(event.target, PARAMS[event.target.id]);\n        play();\n      }\n    }\n  });\n  $(\".slider\").filter(\".signed\").\n    slider(\"option\", \"min\", -1000).\n    slider(\"value\", 0);\n  $('.slider').each(function () {\n      var is = this.id;\n      if (!$('label[for=\"' + is + '\"]').length)\n        $(this).parent().parent().find('th').append($('<label>',\n                                                      {for: is}));\n    });\n\n  var UNITS = {\n    p_env_attack:  function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n    p_env_sustain: function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n    p_env_punch:   function (v) { return '+' + (v * 100).toPrecision(4) + '%'},\n    p_env_decay:   function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n\n    p_base_freq:  'Hz',\n    p_freq_limit: 'Hz',\n    p_freq_ramp:  function (v) {\n      return (44100*Math.log(v)/Math.log(0.5)).toPrecision(4) + ' 8va/sec'; },\n    p_freq_dramp: function (v) {\n      return (v*44100 / Math.pow(2, -44101/44100)).toPrecision(4) +\n        ' 8va/sec^2?'; },\n\n    p_vib_speed:    function (v) { return v === 0 ? 'OFF' :\n                                   (441000/64 * v).toPrecision(4) + ' Hz'},\n    p_vib_strength: function (v) { return v === 0 ? 'OFF' :\n                                   '&plusmn; ' + (v*100).toPrecision(4) + '%' },\n\n    p_arp_mod:   function (v) { return ((v === 1) ? 'OFF' :\n                                        'x ' + (1/v).toPrecision(4)) },\n    p_arp_speed: function (v) { return (v === 0 ? 'OFF' :\n                                        (v / 44100).toPrecision(4) +' sec') },\n\n    p_duty:      function (v) { return (100 * v).toPrecision(4) + '%'; },\n    p_duty_ramp: function (v) { return (8 * 44100 * v).toPrecision(4) +'%/sec'},\n\n    p_repeat_speed: function (v) { return v === 0 ? 'OFF' :\n                                   (44100/v).toPrecision(4) + ' Hz' },\n\n    p_pha_offset: function (v) { return v === 0 ? 'OFF' :\n                                 (1000*v/44100).toPrecision(4) + ' msec' },\n    // Not so sure about this:\n    p_pha_ramp:   function (v) { return v === 0 ? 'OFF' :\n                 (1000*v).toPrecision(4) + ' msec/sec' },\n\n    p_lpf_freq:   function (v) {\n      return (v === 0.1) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },\n    p_lpf_ramp:  function (v) {  if (v === 1) return 'OFF';\n      return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },\n    p_lpf_resonance: function (v) { return (100*(1-v*0.11)).toPrecision(4)+'%';},\n\n    p_hpf_freq:   function (v) {\n      return (v === 0) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },\n    p_hpf_ramp: function (v) {  if (v === 1) return 'OFF';\n      return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },\n\n    sound_vol: function (v) {\n      v = 10 * Math.log(v*v) / Math.log(10);\n      var sign = v >= 0 ? '+' : '';\n      return sign + v.toPrecision(4) + ' dB';\n    }\n  };\n\n  var CONVERSIONS = {\n    p_env_attack:  function (v) { return v * v * 100000.0 },\n    p_env_sustain: function (v) { return v * v * 100000.0 },\n    p_env_punch:   function (v) { return v },\n    p_env_decay:   function (v) { return v * v * 100000.0 },\n\n    p_base_freq:  function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },\n    p_freq_limit: function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },\n    p_freq_ramp:  function (v) { return 1.0 - Math.pow(v, 3.0) * 0.01 },\n    p_freq_dramp: function (v) { return -Math.pow(v, 3.0) * 0.000001 },\n\n    p_vib_speed:    function (v) { return Math.pow(v, 2.0) * 0.01 },\n    p_vib_strength: function (v) { return v * 0.5 },\n\n    p_arp_mod:   function (v) {\n      return v >= 0 ? 1.0 - Math.pow(v, 2) * 0.9 : 1.0 + Math.pow(v, 2) * 10; },\n    p_arp_speed: function (v) { return (v === 1.0) ? 0 :\n                                Math.floor(Math.pow(1.0 - v, 2.0) * 20000 +32)},\n\n    p_duty:      function (v) { return 0.5 - v * 0.5; },\n    p_duty_ramp: function (v) { return -v * 0.00005 },\n\n    p_repeat_speed: function (v) { return (v === 0) ? 0 :\n                                   Math.floor(Math.pow(1-v, 2) * 20000) + 32 },\n\n    p_pha_offset: function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2)*1020 },\n    p_pha_ramp:   function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2) },\n\n    p_lpf_freq:   function (v) { return Math.pow(v, 3) * 0.1 },\n    p_lpf_ramp:   function (v) { return 1.0 + v * 0.0001 },\n    p_lpf_resonance: function (v) { return 5.0 / (1.0 + Math.pow(v, 2) * 20) }, // * (0.01 + fltw);\n\n    p_hpf_freq: function (v) { return Math.pow(v, 2) * 0.1 },\n    p_hpf_ramp: function (v) { return 1.0 + v * 0.0003 },\n\n    sound_vol: function (v) { return Math.exp(v) - 1; }\n  };\n  for (var p in CONVERSIONS) {\n    var control = $('#' + p)[0];\n    control.convert = CONVERSIONS[p];\n    control.units = UNITS[p];\n  }\n\n  gen(\"pickupCoin\");\n});\n\nfunction convert(control, v) {\n  if (control.convert) {\n    v = control.convert(v);\n    control.convertedValue = v;\n    if (typeof control.units === 'function')\n      v = control.units(v);\n    else\n      v = v.toPrecision(4) + ' ' + control.units;\n    $('label[for=\"' + control.id + '\"]').html(v);\n  }\n}\n",
      "mode": "100644",
      "type": "blob"
    },
    "main.coffee": {
      "path": "main.coffee",
      "content": "ApplicationTemplate = require \"./templates/application\"\nglobal.SFXR = require \"./sfxr\"\n\n{Params, SoundEffect} = SFXR\n\nparams = new Params\n\naudio = document.createElement \"audio\"\n\ncreateAndPlay = (type) ->\n  params = new Params\n  params[type]()\n\n  sfx = new SoundEffect(params).generate()\n\n  audio.src = sfx.dataURI\n  audio.play()\n\ndocument.body.appendChild ApplicationTemplate\n  coin: ->\n    createAndPlay(\"pickupCoin\")\n\n  laser: ->\n    createAndPlay(\"laserShoot\")\n\n  explosion: ->\n    createAndPlay(\"explosion\")\n\n  powerUp: ->\n    createAndPlay(\"powerUp\")\n\n  hit: ->\n    createAndPlay(\"hitHurt\")\n\n  jump: ->\n    createAndPlay(\"jump\")\n\n  blip: ->\n    createAndPlay(\"blipSelect\")\n\n  tone: ->\n    createAndPlay(\"tone\")\n",
      "mode": "100644",
      "type": "blob"
    },
    "riffwave.js": {
      "path": "riffwave.js",
      "content": "/*\n * RIFFWAVE.js v0.03 - Audio encoder for HTML5 <audio> elements.\n * Copyright (C) 2011 Pedro Ladaria <pedro.ladaria at Gmail dot com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * version 2 as published by the Free Software Foundation.\n * The full license is available at http://www.gnu.org/licenses/gpl.html\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n *\n * Changelog:\n *\n * 0.01 - First release\n * 0.02 - New faster base64 encoding\n * 0.03 - Blob URLs\n *\n */\n\nvar RIFFWAVE = function(data) {\n\n  this.data = [];        // Byte array containing audio samples\n  this.wav = [];         // Array containing the generated wave file\n  this.dataURI = '';     // http://en.wikipedia.org/wiki/Data_URI_scheme\n\n  this.header = {                         // OFFS SIZE NOTES\n    chunkId      : [0x52,0x49,0x46,0x46], // 0    4    \"RIFF\" = 0x52494646\n    chunkSize    : 0,                     // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)\n    format       : [0x57,0x41,0x56,0x45], // 8    4    \"WAVE\" = 0x57415645\n    subChunk1Id  : [0x66,0x6d,0x74,0x20], // 12   4    \"fmt \" = 0x666d7420\n    subChunk1Size: 16,                    // 16   4    16 for PCM\n    audioFormat  : 1,                     // 20   2    PCM = 1\n    numChannels  : 1,                     // 22   2    Mono = 1, Stereo = 2, etc.\n    sampleRate   : 8000,                  // 24   4    8000, 44100, etc\n    byteRate     : 0,                     // 28   4    SampleRate*NumChannels*BitsPerSample/8\n    blockAlign   : 0,                     // 32   2    NumChannels*BitsPerSample/8\n    bitsPerSample: 8,                     // 34   2    8 bits = 8, 16 bits = 16, etc...\n    subChunk2Id  : [0x64,0x61,0x74,0x61], // 36   4    \"data\" = 0x64617461\n    subChunk2Size: 0                      // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8\n  };\n\n  function u32ToArray(i) { return [i&0xFF, (i>>8)&0xFF, (i>>16)&0xFF, (i>>24)&0xFF]; }\n\n  function u16ToArray(i) { return [i&0xFF, (i>>8)&0xFF]; }\n\n  this.Make = function(data) {\n    if (data instanceof Array) this.data = data;\n    this.header.byteRate = (this.header.sampleRate * this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.blockAlign = (this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.subChunk2Size = this.data.length;\n    this.header.chunkSize = 36 + this.header.subChunk2Size;\n\n    this.wav = this.header.chunkId.concat(\n      u32ToArray(this.header.chunkSize),\n      this.header.format,\n      this.header.subChunk1Id,\n      u32ToArray(this.header.subChunk1Size),\n      u16ToArray(this.header.audioFormat),\n      u16ToArray(this.header.numChannels),\n      u32ToArray(this.header.sampleRate),\n      u32ToArray(this.header.byteRate),\n      u16ToArray(this.header.blockAlign),\n      u16ToArray(this.header.bitsPerSample),\n      this.header.subChunk2Id,\n      u32ToArray(this.header.subChunk2Size),\n      this.data\n    );\n\n    var dat = Uint8Array.from(this.wav);\n    var blob = new Blob([dat], {type: \"audio/wav\"});\n    var url = URL.createObjectURL(blob);\n    this.dataURI = url;\n  };\n\n  if (data instanceof Array) this.Make(data);\n\n}; // end RIFFWAVE\n\n\nif (typeof exports != 'undefined')  // For node.js\n  exports.RIFFWAVE = RIFFWAVE;\n",
      "mode": "100644",
      "type": "blob"
    },
    "sfxr.js": {
      "path": "sfxr.js",
      "content": "// Wave shapes\nvar SQUARE = 0;\nvar SAWTOOTH = 1;\nvar SINE = 2;\nvar NOISE = 3;\n\n// Playback volume\nvar masterVolume = 1;\n\nvar OVERSAMPLING = 8;\n\n\nfunction sqr(x) { return x * x }\nfunction cube(x) { return x * x * x }\nfunction sign(x) { return x < 0 ? -1 : 1 }\nfunction log(x, b) { return Math.log(x) / Math.log(b); }\nvar pow = Math.pow;\n\n// Sound generation parameters are on [0,1] unless noted SIGNED & thus\n// on [-1,1]\nfunction Params() {\n  this.oldParams = true;  // Note what structure this is\n\n  // Wave shape\n  this.wave_type = SQUARE;\n\n  // Envelope\n  this.p_env_attack = 0;   // Attack time\n  this.p_env_sustain = 0.3;  // Sustain time\n  this.p_env_punch = 0;    // Sustain punch\n  this.p_env_decay = 0.4;    // Decay time\n\n  // Tone\n  this.p_base_freq = 0.3;    // Start frequency\n  this.p_freq_limit = 0;   // Min frequency cutoff\n  this.p_freq_ramp = 0;    // Slide (SIGNED)\n  this.p_freq_dramp = 0;   // Delta slide (SIGNED)\n  // Vibrato\n  this.p_vib_strength = 0; // Vibrato depth\n  this.p_vib_speed = 0;    // Vibrato speed\n\n  // Tonal change\n  this.p_arp_mod = 0;      // Change amount (SIGNED)\n  this.p_arp_speed = 0;    // Change speed\n\n  // Square wave duty (proportion of time signal is high vs. low)\n  this.p_duty = 0;         // Square duty\n  this.p_duty_ramp = 0;    // Duty sweep (SIGNED)\n\n  // Repeat\n  this.p_repeat_speed = 0; // Repeat speed\n\n  // Flanger\n  this.p_pha_offset = 0;   // Flanger offset (SIGNED)\n  this.p_pha_ramp = 0;     // Flanger sweep (SIGNED)\n\n  // Low-pass filter\n  this.p_lpf_freq = 1;     // Low-pass filter cutoff\n  this.p_lpf_ramp = 0;     // Low-pass filter cutoff sweep (SIGNED)\n  this.p_lpf_resonance = 0;// Low-pass filter resonance\n  // High-pass filter\n  this.p_hpf_freq = 0;     // High-pass filter cutoff\n  this.p_hpf_ramp = 0;     // High-pass filter cutoff sweep (SIGNED)\n\n  // Sample parameters\n  this.sound_vol = 0.5;\n  this.sample_rate = 44100;\n  this.sample_size = 8;\n}\n\n\nfunction frnd(range) {\n  return Math.random() * range;\n}\n\nfunction rndr(from, to) {\n  return Math.random() * (to - from) + from;\n}\n\nfunction rnd(max) {\n  return Math.floor(Math.random() * (max + 1));\n}\n\n\n// These functions roll up random sounds appropriate to various\n// typical game events:\n\n\nParams.prototype.pickupCoin = function () {\n  this.p_base_freq = 0.4 + frnd(0.5);\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.1);\n  this.p_env_decay = 0.1 + frnd(0.4);\n  this.p_env_punch = 0.3 + frnd(0.3);\n  if (rnd(1)) {\n    this.p_arp_speed = 0.5 + frnd(0.2);\n    this.p_arp_mod = 0.2 + frnd(0.4);\n  }\n  return this;\n};\n\n\nParams.prototype.laserShoot = function () {\n  this.wave_type = rnd(2);\n  if(this.wave_type === SINE && rnd(1))\n    this.wave_type = rnd(1);\n  if (rnd(2) === 0) {\n    this.p_base_freq = 0.3 + frnd(0.6);\n    this.p_freq_limit = frnd(0.1);\n    this.p_freq_ramp = -0.35 - frnd(0.3);\n  } else {\n    this.p_base_freq = 0.5 + frnd(0.5);\n    this.p_freq_limit = this.p_base_freq - 0.2 - frnd(0.6);\n    if (this.p_freq_limit < 0.2) this.p_freq_limit = 0.2;\n    this.p_freq_ramp = -0.15 - frnd(0.2);\n  }\n  if (this.wave_type === SAWTOOTH)\n    this.p_duty = 1;\n  if (rnd(1)) {\n    this.p_duty = frnd(0.5);\n    this.p_duty_ramp = frnd(0.2);\n  } else {\n    this.p_duty = 0.4 + frnd(0.5);\n    this.p_duty_ramp = -frnd(0.7);\n  }\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.2);\n  this.p_env_decay = frnd(0.4);\n  if (rnd(1))\n    this.p_env_punch = frnd(0.3);\n  if (rnd(2) === 0) {\n    this.p_pha_offset = frnd(0.2);\n    this.p_pha_ramp = -frnd(0.2);\n  }\n  //if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n\n  return this;\n};\n\n\nParams.prototype.explosion = function () {\n  this.wave_type = NOISE;\n  if (rnd(1)) {\n    this.p_base_freq = sqr(0.1 + frnd(0.4));\n    this.p_freq_ramp = -0.1 + frnd(0.4);\n  } else {\n    this.p_base_freq = sqr(0.2 + frnd(0.7));\n    this.p_freq_ramp = -0.2 - frnd(0.2);\n  }\n  if (rnd(4) === 0)\n    this.p_freq_ramp = 0;\n  if (rnd(2) === 0)\n    this.p_repeat_speed = 0.3 + frnd(0.5);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.3);\n  this.p_env_decay = frnd(0.5);\n  if (rnd(1)) {\n    this.p_pha_offset = -0.3 + frnd(0.9);\n    this.p_pha_ramp = -frnd(0.3);\n  }\n  this.p_env_punch = 0.2 + frnd(0.6);\n  if (rnd(1)) {\n    this.p_vib_strength = frnd(0.7);\n    this.p_vib_speed = frnd(0.6);\n  }\n  if (rnd(2) === 0) {\n    this.p_arp_speed = 0.6 + frnd(0.3);\n    this.p_arp_mod = 0.8 - frnd(1.6);\n  }\n\n  return this;\n};\n\n\nParams.prototype.powerUp = function () {\n  if (rnd(1)) {\n    this.wave_type = SAWTOOTH;\n    this.p_duty = 1;\n  } else {\n    this.p_duty = frnd(0.6);\n  }\n  this.p_base_freq = 0.2 + frnd(0.3);\n  if (rnd(1)) {\n    this.p_freq_ramp = 0.1 + frnd(0.4);\n    this.p_repeat_speed = 0.4 + frnd(0.4);\n  } else {\n    this.p_freq_ramp = 0.05 + frnd(0.2);\n    if (rnd(1)) {\n      this.p_vib_strength = frnd(0.7);\n      this.p_vib_speed = frnd(0.6);\n    }\n  }\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.4);\n  this.p_env_decay = 0.1 + frnd(0.4);\n\n  return this;\n};\n\n\nParams.prototype.hitHurt = function () {\n  this.wave_type = rnd(2);\n  if (this.wave_type === SINE)\n    this.wave_type = NOISE;\n  if (this.wave_type === SQUARE)\n    this.p_duty = frnd(0.6);\n  if (this.wave_type === SAWTOOTH)\n    this.p_duty = 1;\n  this.p_base_freq = 0.2 + frnd(0.6);\n  this.p_freq_ramp = -0.3 - frnd(0.4);\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.1);\n  this.p_env_decay = 0.1 + frnd(0.2);\n  if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n  return this;\n};\n\n\nParams.prototype.jump = function () {\n  this.wave_type = SQUARE;\n  this.p_duty = frnd(0.6);\n  this.p_base_freq = 0.3 + frnd(0.3);\n  this.p_freq_ramp = 0.1 + frnd(0.2);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.3);\n  this.p_env_decay = 0.1 + frnd(0.2);\n  if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n  if (rnd(1))\n    this.p_lpf_freq = 1 - frnd(0.6);\n  return this;\n};\n\n\nParams.prototype.blipSelect = function () {\n  this.wave_type = rnd(1);\n  if (this.wave_type === SQUARE)\n    this.p_duty = frnd(0.6);\n  else\n    this.p_duty = 1;\n  this.p_base_freq = 0.2 + frnd(0.4);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.1);\n  this.p_env_decay = frnd(0.2);\n  this.p_hpf_freq = 0.1;\n  return this;\n};\n\n\nParams.prototype.tone = function () {\n  this.wave_type = SINE;\n  this.p_base_freq = 0.35173364; // 440 Hz\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.6641; // 1 sec\n  this.p_env_decay = 0;\n  this.p_env_punch = 0;\n  return this;\n};\n\n\nParams.prototype.mutate = function () {\n  if (rnd(1)) this.p_base_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_freq_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_freq_dramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_duty += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_duty_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_strength += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_delay += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_attack += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_sustain += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_decay += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_punch += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_resonance += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_hpf_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_hpf_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_pha_offset += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_pha_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_repeat_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_arp_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_arp_mod += frnd(0.1) - 0.05;\n};\n\n\nParams.prototype.random = function () {\n  if (rnd(1))\n    this.p_base_freq = cube(frnd(2) - 1) + 0.5;\n  else\n    this.p_base_freq = sqr(frnd(1));\n  this.p_freq_limit = 0;\n  this.p_freq_ramp = Math.pow(frnd(2) - 1, 5);\n  if (this.p_base_freq > 0.7 && this.p_freq_ramp > 0.2)\n    this.p_freq_ramp = -this.p_freq_ramp;\n  if (this.p_base_freq < 0.2 && this.p_freq_ramp < -0.05)\n    this.p_freq_ramp = -this.p_freq_ramp;\n  this.p_freq_dramp = Math.pow(frnd(2) - 1, 3);\n  this.p_duty = frnd(2) - 1;\n  this.p_duty_ramp = Math.pow(frnd(2) - 1, 3);\n  this.p_vib_strength = Math.pow(frnd(2) - 1, 3);\n  this.p_vib_speed = rndr(-1, 1);\n  this.p_env_attack = cube(rndr(-1, 1));\n  this.p_env_sustain = sqr(rndr(-1, 1));\n  this.p_env_decay = rndr(-1, 1);\n  this.p_env_punch = Math.pow(frnd(0.8), 2);\n  if (this.p_env_attack + this.p_env_sustain + this.p_env_decay < 0.2) {\n    this.p_env_sustain += 0.2 + frnd(0.3);\n    this.p_env_decay += 0.2 + frnd(0.3);\n  }\n  this.p_lpf_resonance = rndr(-1, 1);\n  this.p_lpf_freq = 1 - Math.pow(frnd(1), 3);\n  this.p_lpf_ramp = Math.pow(frnd(2) - 1, 3);\n  if (this.p_lpf_freq < 0.1 && this.p_lpf_ramp < -0.05)\n    this.p_lpf_ramp = -this.p_lpf_ramp;\n  this.p_hpf_freq = Math.pow(frnd(1), 5);\n  this.p_hpf_ramp = Math.pow(frnd(2) - 1, 5);\n  this.p_pha_offset = Math.pow(frnd(2) - 1, 3);\n  this.p_pha_ramp = Math.pow(frnd(2) - 1, 3);\n  this.p_repeat_speed = frnd(2) - 1;\n  this.p_arp_speed = frnd(2) - 1;\n  this.p_arp_mod = frnd(2) - 1;\n  return this;\n};\n\n\nfunction SoundEffect(ps) {\n  if (ps.oldParams)\n    this.initFromUI(ps);\n  else\n    this.init(ps);\n}\n\n\nSoundEffect.prototype.initFromUI = function (ps) {\n  //\n  // Convert user-facing parameter values to units usable by the sound\n  // generator\n  //\n\n  this.initForRepeat = function() {\n    this.elapsedSinceRepeat = 0;\n\n    this.period = 100 / (ps.p_base_freq * ps.p_base_freq + 0.001);\n    this.periodMax = 100 / (ps.p_freq_limit * ps.p_freq_limit + 0.001);\n    this.enableFrequencyCutoff = (ps.p_freq_limit > 0);\n    this.periodMult = 1 - Math.pow(ps.p_freq_ramp, 3) * 0.01;\n    this.periodMultSlide = -Math.pow(ps.p_freq_dramp, 3) * 0.000001;\n\n    this.dutyCycle = 0.5 - ps.p_duty * 0.5;\n    this.dutyCycleSlide = -ps.p_duty_ramp * 0.00005;\n\n    if (ps.p_arp_mod >= 0)\n      this.arpeggioMultiplier = 1 - Math.pow(ps.p_arp_mod, 2) * .9;\n    else\n      this.arpeggioMultiplier = 1 + Math.pow(ps.p_arp_mod, 2) * 10;\n    this.arpeggioTime = Math.floor(Math.pow(1 - ps.p_arp_speed, 2) * 20000 + 32);\n    if (ps.p_arp_speed === 1)\n      this.arpeggioTime = 0;\n  }\n\n  this.initForRepeat();  // First time through, this is a bit of a misnomer\n\n  // Waveform shape\n  this.waveShape = parseInt(ps.wave_type);\n\n  // Filter\n  this.fltw = Math.pow(ps.p_lpf_freq, 3) * 0.1;\n  this.enableLowPassFilter = (ps.p_lpf_freq != 1);\n  this.fltw_d = 1 + ps.p_lpf_ramp * 0.0001;\n  this.fltdmp = 5 / (1 + Math.pow(ps.p_lpf_resonance, 2) * 20) *\n    (0.01 + this.fltw);\n  if (this.fltdmp > 0.8) this.fltdmp=0.8;\n  this.flthp = Math.pow(ps.p_hpf_freq, 2) * 0.1;\n  this.flthp_d = 1 + ps.p_hpf_ramp * 0.0003;\n\n  // Vibrato\n  this.vibratoSpeed = Math.pow(ps.p_vib_speed, 2) * 0.01;\n  this.vibratoAmplitude = ps.p_vib_strength * 0.5;\n\n  // Envelope\n  this.envelopeLength = [\n    Math.floor(ps.p_env_attack * ps.p_env_attack * 100000),\n    Math.floor(ps.p_env_sustain * ps.p_env_sustain * 100000),\n    Math.floor(ps.p_env_decay * ps.p_env_decay * 100000)\n  ];\n  this.envelopePunch = ps.p_env_punch;\n\n  // Flanger\n  this.flangerOffset = Math.pow(ps.p_pha_offset, 2) * 1020;\n  if (ps.p_pha_offset < 0) this.flangerOffset = -this.flangerOffset;\n  this.flangerOffsetSlide = Math.pow(ps.p_pha_ramp, 2) * 1;\n  if (ps.p_pha_ramp < 0) this.flangerOffsetSlide = -this.flangerOffsetSlide;\n\n  // Repeat\n  this.repeatTime = Math.floor(Math.pow(1 - ps.p_repeat_speed, 2) * 20000\n                               + 32);\n  if (ps.p_repeat_speed === 0)\n    this.repeatTime = 0;\n\n  this.gain = Math.exp(ps.sound_vol) - 1;\n\n  this.sampleRate = ps.sample_rate;\n  this.bitsPerChannel = ps.sample_size;\n\n  console.log(this);\n};\n\n\nSoundEffect.prototype.init = function (ps) {\n  //\n  // Convert user-facing parameter values to units usable by the sound\n  // generator\n  //\n\n  this.initForRepeat = function() {\n    this.elapsedSinceRepeat = 0;\n\n    this.period = OVERSAMPLING * 44100 / ps.frequency;\n    this.periodMax = OVERSAMPLING * 44100 / ps.frequencyMin;\n    this.enableFrequencyCutoff = (ps.frequencyMin > 0);\n    this.periodMult = Math.pow(.5, ps.frequencySlide / 44100);\n    this.periodMultSlide = ps.frequencySlideSlide * Math.pow(2, -44101/44100)\n      / 44100;\n\n    this.dutyCycle = ps.dutyCycle;\n    this.dutyCycleSlide = ps.dutyCycleSweep / (OVERSAMPLING * 44100);\n\n    this.arpeggioMultiplier = 1 / ps.arpeggioFactor;\n    this.arpeggioTime = ps.arpeggioDelay * 44100;\n  }\n  this.initForRepeat();  // First time through, this is a bit of a misnomer\n\n  // Waveform shape\n  this.waveShape = ps.shape;\n\n  // Low pass filter\n  this.fltw = ps.lowPassFrequency / (OVERSAMPLING * 44100 + ps.lowPassFrequency);\n  this.enableLowPassFilter = ps.lowPassFrequency < 44100;\n  this.fltw_d = Math.pow(ps.lowPassSweep, 1/44100);\n  this.fltdmp = (1 - ps.lowPassResonance) * 9 * (.01 + this.fltw);\n\n  // High pass filter\n  this.flthp = ps.highPassFrequency / (OVERSAMPLING * 44100 + ps.highPassFrequency);\n  this.flthp_d = Math.pow(ps.highPassSweep, 1/44100);\n\n  // Vibrato\n  this.vibratoSpeed = ps.vibratoRate * 64 / 44100 / 10;\n  this.vibratoAmplitude = ps.vibratoDepth;\n\n  // Envelope\n  this.envelopeLength = [\n    Math.floor(ps.attack * 44100),\n    Math.floor(ps.sustain * 44100),\n    Math.floor(ps.decay * 44100)\n  ];\n  this.envelopePunch = ps.punch;\n\n  // Flanger\n  this.flangerOffset = ps.flangerOffset * 44100;\n  this.flangerOffsetSlide = ps.flangerSweep;\n\n  // Repeat\n  this.repeatTime = ps.retriggerRate ? 1 / (44100 * ps.retriggerRate) : 0;\n\n  // Gain\n  this.gain = Math.sqrt(Math.pow(10, ps.gain/10));\n\n  this.sampleRate = ps.sampleRate;\n  this.bitsPerChannel = ps.sampleSize;\n};\n\n\nSoundEffect.prototype.generate = function () {\n  var fltp = 0;\n  var fltdp = 0;\n  var fltphp = 0;\n\n  var noise_buffer = Array(32);\n  for (var i = 0; i < 32; ++i)\n    noise_buffer[i] = Math.random() * 2 - 1;\n\n  var envelopeStage = 0;\n  var envelopeElapsed = 0;\n\n  var vibratoPhase = 0;\n\n  var phase = 0;\n  var ipp = 0;\n  var flanger_buffer = Array(1024);\n  for (var i = 0; i < 1024; ++i)\n    flanger_buffer[i] = 0;\n\n  var num_clipped = 0;\n\n  var buffer = [];\n\n  var sample_sum = 0;\n  var num_summed = 0;\n  var summands = Math.floor(44100 / this.sampleRate);\n\n  for(var t = 0; ; ++t) {\n\n    // Repeats\n    if (this.repeatTime != 0 && ++this.elapsedSinceRepeat >= this.repeatTime)\n      this.initForRepeat();\n\n    // Arpeggio (single)\n    if(this.arpeggioTime != 0 && t >= this.arpeggioTime) {\n      this.arpeggioTime = 0;\n      this.period *= this.arpeggioMultiplier;\n    }\n\n    // Frequency slide, and frequency slide slide!\n    this.periodMult += this.periodMultSlide;\n    this.period *= this.periodMult;\n    if(this.period > this.periodMax) {\n      this.period = this.periodMax;\n      if (this.enableFrequencyCutoff)\n        break;\n    }\n\n    // Vibrato\n    var rfperiod = this.period;\n    if (this.vibratoAmplitude > 0) {\n      vibratoPhase += this.vibratoSpeed;\n      rfperiod = this.period * (1 + Math.sin(vibratoPhase) * this.vibratoAmplitude);\n    }\n    var iperiod = Math.floor(rfperiod);\n    if (iperiod < OVERSAMPLING) iperiod = OVERSAMPLING;\n\n    // Square wave duty cycle\n    this.dutyCycle += this.dutyCycleSlide;\n    if (this.dutyCycle < 0) this.dutyCycle = 0;\n    if (this.dutyCycle > 0.5) this.dutyCycle = 0.5;\n\n    // Volume envelope\n    if (++envelopeElapsed > this.envelopeLength[envelopeStage]) {\n      envelopeElapsed = 0;\n      if (++envelopeStage > 2)\n        break;\n    }\n    var env_vol;\n    var envf = envelopeElapsed / this.envelopeLength[envelopeStage];\n    if (envelopeStage === 0) {         // Attack\n      env_vol = envf;\n    } else if (envelopeStage === 1) {  // Sustain\n      env_vol = 1 + (1 - envf) * 2 * this.envelopePunch;\n    } else {                           // Decay\n      env_vol = 1 - envf;\n    }\n\n    // Flanger step\n    this.flangerOffset += this.flangerOffsetSlide;\n    var iphase = Math.abs(Math.floor(this.flangerOffset));\n    if (iphase > 1023) iphase = 1023;\n\n    if (this.flthp_d != 0) {\n      this.flthp *= this.flthp_d;\n      if (this.flthp < 0.00001)\n        this.flthp = 0.00001;\n      if (this.flthp > 0.1)\n        this.flthp = 0.1;\n    }\n\n    // 8x oversampling\n    var sample = 0;\n    for (var si = 0; si < OVERSAMPLING; ++si) {\n      var sub_sample = 0;\n      phase++;\n      if (phase >= iperiod) {\n        phase %= iperiod;\n        if (this.waveShape === NOISE)\n          for(var i = 0; i < 32; ++i)\n            noise_buffer[i] = Math.random() * 2 - 1;\n      }\n\n      // Base waveform\n      var fp = phase / iperiod;\n      if (this.waveShape === SQUARE) {\n        if (fp < this.dutyCycle)\n          sub_sample=0.5;\n        else\n          sub_sample=-0.5;\n      } else if (this.waveShape === SAWTOOTH) {\n        if (fp < this.dutyCycle)\n          sub_sample = -1 + 2 * fp/this.dutyCycle;\n        else\n          sub_sample = 1 - 2 * (fp-this.dutyCycle)/(1-this.dutyCycle);\n      } else if (this.waveShape === SINE) {\n        sub_sample = Math.sin(fp * 2 * Math.PI);\n      } else if (this.waveShape === NOISE) {\n        sub_sample = noise_buffer[Math.floor(phase * 32 / iperiod)];\n      } else {\n        throw \"ERROR: Bad wave type: \" + this.waveShape;\n      }\n\n      // Low-pass filter\n      var pp = fltp;\n      this.fltw *= this.fltw_d;\n      if (this.fltw < 0) this.fltw = 0;\n      if (this.fltw > 0.1) this.fltw = 0.1;\n      if (this.enableLowPassFilter) {\n        fltdp += (sub_sample - fltp) * this.fltw;\n        fltdp -= fltdp * this.fltdmp;\n      } else {\n        fltp = sub_sample;\n        fltdp = 0;\n      }\n      fltp += fltdp;\n\n      // High-pass filter\n      fltphp += fltp - pp;\n      fltphp -= fltphp * this.flthp;\n      sub_sample = fltphp;\n\n      // Flanger\n      flanger_buffer[ipp & 1023] = sub_sample;\n      sub_sample += flanger_buffer[(ipp - iphase + 1024) & 1023];\n      ipp = (ipp + 1) & 1023;\n\n      // final accumulation and envelope application\n      sample += sub_sample * env_vol;\n    }\n\n    // Accumulate samples appropriately for sample rate\n    sample_sum += sample;\n    if (++num_summed >= summands) {\n      num_summed = 0;\n      sample = sample_sum / summands;\n      sample_sum = 0;\n    } else {\n      continue;\n    }\n\n    sample = sample / OVERSAMPLING * masterVolume;\n    sample *= this.gain;\n\n    if (this.bitsPerChannel === 8) {\n      // Rescale [-1, 1) to [0, 256)\n      sample = Math.floor((sample + 1) * 128);\n      if (sample > 255) {\n        sample = 255;\n        ++num_clipped;\n      } else if (sample < 0) {\n        sample = 0;\n        ++num_clipped;\n      }\n      buffer.push(sample);\n    } else {\n      // Rescale [-1, 1) to [-32768, 32768)\n      sample = Math.floor(sample * (1<<15));\n      if (sample >= (1<<15)) {\n        sample = (1 << 15)-1;\n        ++num_clipped;\n      } else if (sample < -(1<<15)) {\n        sample = -(1 << 15);\n        ++num_clipped;\n      }\n      buffer.push(sample & 0xFF);\n      buffer.push((sample >> 8) & 0xFF);\n    }\n  }\n\n  var wave = new RIFFWAVE();\n  wave.header.sampleRate = this.sampleRate;\n  wave.header.bitsPerSample = this.bitsPerChannel;\n  wave.Make(buffer);\n  wave.clipping = num_clipped;\n  return wave;\n};\n\n// For node.js\nif (typeof exports !== 'undefined')  {\n  var RIFFWAVE = require(\"./riffwave\").RIFFWAVE;\n  exports.Params = Params;\n  exports.SoundEffect = SoundEffect;\n  exports.SQUARE = SQUARE;\n  exports.SAWTOOTH = SAWTOOTH;\n  exports.SINE = SINE;\n  exports.NOISE = NOISE;\n}\n",
      "mode": "100644",
      "type": "blob"
    },
    "style.styl": {
      "path": "style.styl",
      "content": "button, p, #sound_vol {\n  width: 160px;\n}\n\n#sound_vol {\n  margin-top: 4px;\n}\n\n#shape label {\n  width: 80px;\n}\n\n#hz label {\n  width: 40px;\n}\n\n#bits label {\n  width: 80px;\n}\n\n#wav {\n  font-weight: bold;\n}\n\n\ndiv {\n  display: inline-block;\n}\n\nh1 {\n  padding-right: 1em;\n  padding-top: 0;\n  margin-top: 0;\n}\n\nbody {\n  padding-left: 2em;\n}\n\n.slider {\n  width: 120px;\n}\n\n.ui-widget-content .ui-state-default {\n  border-color: #F58400;\n}\n\n* {\n  font: 10pt Helvetica;\n}\n\nh1 { font-size: 24pt; }\nh2 { font-size: 12pt; }\n\nbutton, input, label {\n  font-size: 10px;\n}\n\ndiv {\n  vertical-align: top;\n}\n\nth {\n  padding-left: 1em;\n  text-align: left;\n}\n\nhr {\n  font-size: 3px;\n}\n\n#demo-frame > div.demo { padding: 10px !important; }\n\n#stats td {\n  text-align: right;\n}\n\n#stats {\n  width: 80%;\n}\n\na {\n  text-decoration: none;\n  color: #0000ff;\n}\n\n#uncopy {\n  margin-top: -4px;\n  border: solid 1px #0000ff;\n  border-radius: 10px;\n  width: 8px;\n  height: 8px;\n  display: inline-block;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 6px;\n  font-size: 10px;\n}\n\n#generators button {\n  margin-bottom: 2px;\n}\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/application.jadelet": {
      "path": "templates/application.jadelet",
      "content": "application\n  button(click=@coin) Coin\n  button(click=@laser) Laser\n  button(click=@explosion) Explosion\n  button(click=@powerUp) Power Up\n  button(click=@hit) Hit\n  button(click=@jump) Jump\n  button(click=@blip) Blip\n  button(click=@tone) Tone\n",
      "mode": "100644",
      "type": "blob"
    },
    "test.js": {
      "path": "test.js",
      "content": "// For testing with node.js\n\nvar sys = require(\"util\");\n\nvar RIFFWAVE = require(\"./riffwave.js\").RIFFWAVE;\nvar sfxr = require(\"./sfxr.js\");\n\nfunction dump(that, title) {\n  if (title) console.log('\\n' + title + '\\n');\n  for (var i in that)\n    if (typeof that[i] !== 'function')\n      console.log(i, that[i]);\n}\n\nfunction diff(a, b, title) {\n  if (title) console.log('\\n' + title + '\\n');\n  for (var i in a) {\n    if (a.hasOwnProperty(i) && typeof a[i] !== 'function') {\n      if (b.hasOwnProperty(i)) {\n        if (a[i] !== b[i])\n          console.log('%', i, a[i], b[i])\n      } else\n        console.log('<', i, a[i]);\n    }\n  }\n  for (var i in b) {\n    if (b.hasOwnProperty(i) && !a.hasOwnProperty(i)) {\n      console.log('>', i, b[i]);\n    }\n  }\n}\n\n\n//var sound = new sfxr.SoundEffect((new sfxr.Params()).tone()).generate();\n/*\nvar knobs = new sfxr.Knobs({\n  shape: sfxr.SAWTOOTH,\n  attack: 0.1,\n  decay: 0.1,\n  sustain: 1,\n  frequency: 440,\n});\nvar sound = new sfxr.SoundEffect(knobs).generate();\n*/\n\n\n/*\nconsole.log(\"\\nKNOBS TONE\\n\")\nvar a, b;\ndump(a = new sfxr.SoundEffect(new sfxr.Knobs().tone()))\n\nconsole.log(\"\\nKNOBS FOR IT\\n\");\ndump(new sfxr.Knobs().tone());\n\nconsole.log(\"\\nPARAMS TONE\\n\")\ndump(b = new sfxr.SoundEffect(new sfxr.Params().tone()));\n\nconsole.log(\"\\nPARAMS FOR IT\\n\")\ndump(new sfxr.Params().tone());\n\nconsole.log('\\nDIFF <knobs >params\\n');\ndiff(a, b)\n*/\n\nvar x = 'random';\n\nvar sound = new sfxr.SoundEffect(new sfxr.Knobs()[x]()).generate();\nrequire(\"fs\").writeFile(\"./test.wav\", new Buffer(sound.wav), 'binary',\n                        function(err) {\n                          if(err) {\n                            sys.puts(err);\n                          } else {\n                            sys.puts(\"test.wav saved!\");\n                          }\n                        });\n\nvar p0 = new sfxr.Params()[x](0);\nvar p1 = new sfxr.Params()[x](1);\nvar q0 = new sfxr.Knobs().translate(p0);\nvar q1 = new sfxr.Knobs().translate(p1);\ndump(p0, 'PARAMS 0');\ndump(p1, 'PARAMS 1');\ndump(q0, 'KNOBS 0');\ndump(q1, 'KNOBS 1');\ndiff(q0, q1, 'DIFF KNOBS');\n",
      "mode": "100644",
      "type": "blob"
    },
    "knobs.js": {
      "path": "knobs.js",
      "content": "\nvar defaultKnobs = {\n  shape: SQUARE, // SQUARE/SAWTOOTH/SINE/NOISE\n\n  attack:  0,   // sec\n  sustain: 0.2, // sec\n  punch:   0,   // proportion\n  decay:   0.2, // sec\n\n  frequency:        1000, // Hz\n  frequencyMin:        0, // Hz\n  frequencySlide:      0, // 8va/sec\n  frequencySlideSlide: 0, // 8va/sec/sec\n\n  vibratoDepth:  0, // proportion\n  vibratoRate:  10, // Hz\n\n  arpeggioFactor: 1,   // multiple of frequency\n  arpeggioDelay:  0.1, // sec\n\n  dutyCycle:      0.5, // proportion of wavelength\n  dutyCycleSweep: 0,   // proportion/second\n\n  retriggerRate: 0, // Hz\n\n  flangerOffset: 0, // sec\n  flangerSweep:  0, // offset/sec\n\n  lowPassFrequency: 44100, // Hz\n  lowPassSweep:     1,     // ^sec\n  lowPassResonance: 0.5,   // proportion\n\n  highPassFrequency: 0, // Hz\n  highPassSweep:     0, // ^sec\n\n  gain: -10, // dB\n\n  sampleRate: 44100, // Hz\n  sampleSize: 8,     // bits per channel\n};\n\n\nfunction Knobs(settings) {\n  settings = settings||{};\n  for (var i in defaultKnobs) {\n    if (settings.hasOwnProperty(i))\n      this[i] = settings[i];\n    else\n      this[i] = defaultKnobs[i];\n  }\n}\n\n// Translate from UI-friendly settings to human-friendly ones\nKnobs.prototype.translate = function (ps) {\n  this.shape = ps.wave_type;\n\n  this.attack = sqr(ps.p_env_attack) * 100000 / 44100;\n  this.sustain = sqr(ps.p_env_sustain) * 100000 / 44100;\n  this.punch = ps.p_env_punch;\n  this.decay = sqr(ps.p_env_decay) * 100000 / 44100;\n\n  this.frequency = OVERSAMPLING * 441 * (sqr(ps.p_base_freq) + 0.001);\n  if (ps.p_freq_limit > 0)\n    this.frequencyMin = OVERSAMPLING * 441 * (sqr(ps.p_freq_limit) + 0.001);\n  else\n    this.frequencyMin = 0;\n  this.enableFrequencyCutoff = (ps.p_freq_limit > 0);\n  this.frequencySlide = 44100 * log(1 - cube(ps.p_freq_ramp) / 100, 0.5);\n  this.frequencySlideSlide = -cube(ps.p_freq_dramp) / 1000000 *\n    44100 * pow(2, 44101/44100);\n\n  this.vibratoRate = 44100 * 10 / 64 * sqr(ps.p_vib_speed) / 100;\n  this.vibratoDepth = ps.p_vib_strength / 2;\n\n  this.arpeggioFactor = 1 / ((ps.p_arp_mod >= 0) ?\n                             1 - sqr(ps.p_arp_mod) * 0.9 :\n                             1 + sqr(ps.p_arp_mod) * 10);\n  this.arpeggioDelay = ((ps.p_arp_speed === 1) ? 0 :\n                Math.floor(sqr(1 - ps.p_arp_speed) * 20000 + 32) / 44100);\n\n  this.dutyCycle = (1 - ps.p_duty) / 2;\n  this.dutyCycleSweep = OVERSAMPLING * 44100 * -ps.p_duty_ramp / 20000;\n\n  this.retriggerRate = 44100 / ((ps.p_repeat_speed === 0) ? 0 :\n                       Math.floor(sqr(1 - ps.p_repeat_speed) * 20000) + 32);\n\n  this.flangerOffset = sign(ps.p_pha_offset) *\n    sqr(ps.p_pha_offset) * 1020 / 44100;\n  this.flangerSweep = sign(ps.p_pha_ramp) * sqr(ps.p_pha_ramp);\n\n  this.enableLowPassFilter = (ps.p_lpf_freq != 1);\n  function flurp(x) { return x / (1-x) }\n  this.lowPassFrequency = ps.p_lpf_freq === 1 ? 44100 :\n    Math.round(OVERSAMPLING * 44100 * flurp(cube(ps.p_lpf_freq) / 10));\n  this.lowPassSweep = pow(1 + ps.p_lpf_ramp / 10000, 44100);\n  this.lowPassResonance = 1 - (5 / (1 + sqr(ps.p_lpf_resonance) * 20)) / 9;\n\n  this.highPassFrequency = Math.round(OVERSAMPLING * 44100 *\n                                      flurp(sqr(ps.p_hpf_freq) / 10));\n  this.highPassSweep = pow(1 + ps.p_hpf_ramp * 0.0003, 44100);\n\n  this.gain = 10 * log(sqr(Math.exp(ps.sound_vol) - 1), 10);\n\n  this.sampleRate = ps.sample_rate;\n  this.sampleSize = ps.sample_size;\n\n  return this;\n};\n\nKnobs.prototype.pickupCoin = function () {\n  this.frequency = rndr(568, 2861);\n  this.attack = 0;\n  this.sustain = frnd(0.227);\n  this.decay = rndr(0.227, 0.567);\n  this.punch = rndr(0.3, 0.6);\n  if (rnd(1)) {\n    this.arpeggioFactor = rndr(1.037, 1.479);\n    this.arpeggioDelay = rndr(0.042, 0.114);\n  }\n  return this;\n};\n\nKnobs.prototype.laserShoot = function () {\n  this.shape = rnd(2);\n  if(this.shape === SINE && rnd(1))\n    this.shape = rnd(1);\n  if (rnd(2) === 0) {\n    this.frequency = rndr(321, 2861);\n    this.frequencyMin = frnd(38.8);\n    this.frequencySlide = rndr(-27.3, -174.5);\n  } else {\n    this.frequency = rndr(321, 3532);\n    this.frequencyMin = rndr(144, 2/3 * this.frequency);\n    this.frequencySlide = rndr(-2.15, -27.27);\n  }\n  if (this.shape === SAWTOOTH)\n    this.dutyCycle = 0;\n  if (rnd(1)) {\n    this.dutyCycle = rndr(1/4, 1/2);\n    this.dutyCycleSweep = rndr(0, -3.528);\n  } else {\n    this.dutyCycle = rndr(0.05, 0.3);\n    this.dutyCycleSweep = frnd(12.35);\n  }\n  this.attack = 0;\n  this.sustain = rndr(0.02, 0.2);\n  this.decay = frnd(0.36);\n  if (rnd(1))\n    this.punch = frnd(0.3);\n  if (rnd(2) === 0) {\n    this.flangerOffset = frnd(0.001);\n    this.flangerSweep = -frnd(0.04);\n  }\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n\n  return this;\n};\n\nKnobs.prototype.explosion = function () {\n  this.shape = NOISE;\n  if (rnd(1)) {\n    this.frequency = rndr(4, 224);\n    this.frequencySlide = rndr(-0.623, 17.2);\n  } else {\n    this.frequency = rndr(9, 2318);\n    this.frequencySlide = rndr(-5.1, -40.7);\n  }\n  if (rnd(4) === 0)\n    this.frequencySlide = 0;\n  if (rnd(2) === 0)\n    this.retriggerRate = rndr(4.5, 53);\n  this.attack = 0;\n  this.sustain = rndr(0.0227, 0.363);\n  this.decay = frnd(0.567);\n  if (rnd(1)) {\n    this.flangerOffset = rndr(-0.0021, 0.0083);\n    this.flangerSweep = -frnd(0.09);\n  }\n  this.punch = 0.2 + frnd(0.6);\n  if (rnd(1)) {\n    this.vibratoDepth = frnd(0.35);\n    this.vibratoRate = frnd(24.8);\n  }\n  if (rnd(2) === 0) {\n    this.arpeggioFactor = rndr(0.135, 2.358);\n    this.arpeggioDelay = rndr(0.00526, 0.0733);\n  }\n  return this;\n};\n\n\nKnobs.prototype.powerUp = function () {\n  if (rnd(1)) {\n    this.shape = SAWTOOTH;\n    this.dutyCycle = 0;\n  } else {\n    this.dutyCycle = rndr(0.2, 0.5);\n  }\n  this.frequency = rndr(145, 886);\n  if (rnd(1)) {\n    this.frequencySlide = rndr(0.636, 79.6);\n    this.retriggerRate = rndr(6, 53);\n  } else {\n    this.frequencySlide = rndr(0.0795, 9.94);\n    if (rnd(1)) {\n      this.vibratoDepth = frnd(0.35);\n      this.vibratoRate = frnd(24.8);\n    }\n  }\n  this.attack = 0;\n  this.sustain = frnd(0.363);\n  this.decay = rndr(0.023, 0.57);\n\n  return this;\n};\n\nKnobs.prototype.hitHurt = function () {\n  this.shape = rnd(2);\n  if (this.shape === SINE)\n    this.shape = NOISE;\n  if (this.shape === SQUARE)\n    this.dutyCycle = rndr(0.2, 0.5);\n  if (this.shape === SAWTOOTH)\n    this.dutyCycle = 0;\n  this.frequency = rndr(145, 2261);\n  this.frequencySlide = rndr(-17.2, -217.9);\n  this.attack = 0;\n  this.sustain = frnd(0.023);\n  this.decay = rndr(0.023, 0.2);\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n  return this;\n};\n\nKnobs.prototype.jump = function () {\n  this.shape = SQUARE;\n  this.dutyCycle = rndr(0.2, 0.5);\n  this.frequency = rndr(321, 1274);\n  this.frequencySlide = rndr(0.64, 17.2);\n  this.attack = 0;\n  this.sustain = rndr(0.023, 0.36);\n  this.decay = rndr(0.023, 0.2);\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n  if (rnd(1))\n    this.lowPassFrequency = rndr(2272, 44100);\n  return this;\n};\n\n\nKnobs.prototype.blipSelect = function () {\n  this.shape = rnd(1);\n  if (this.shape === SQUARE)\n    this.dutyCycle = rndr(0.2, 0.5);\n  else\n    this.dutyCycle = 0;\n  this.frequency = rndr(145, 1274);\n  this.attack = 0;\n  this.sustain = rndr(0.023, 0.09);\n  this.decay = frnd(0.09);\n  this.highPassFrequency = 353;\n  return this;\n};\n\nKnobs.prototype.random = function () {\n  if (rnd(1))\n    this.frequency = rndr(885.5, 7941.5);\n  else\n    this.frequency = rndr(3.5, 3532);\n  this.frequencySlide = rndr(-633, 639);\n  if (this.frequency > 1732 && this.frequencySlide > 5)\n    this.frequencySlide = -this.frequencySlide;\n  if (this.frequency < 145 && this.frequencySlide < -0.088)\n    this.frequencySlide = -this.frequencySlide;\n  this.frequencySlideSlide = rndr(-0.88, 0.88);\n  this.dutyCycle = frnd(1);\n  this.dudyCycleSweep = rndr(-17.64, 17.64);\n  this.vibratoDepth = rndr(-0.5, 0.5);\n  this.vibratoRate = rndr(0, 69);\n  this.attack = cube(frnd(1)) * 2.26;\n  this.sustain = sqr(frnd(1)) * 2.26 + 0.09;\n  this.decay = frnd(1) * 2.26;\n  this.punch = sqr(frnd(1)) * 0.64;\n  if (this.attack + this.sustain + this.decay < 0.45) {\n    this.sustain += rndr(0.5, 1.25);\n    this.decay += rndr(0.5, 1.25);\n  }\n  this.lowPassResonance = rndr(0.444, 0.97);\n  this.lowPassFrequency = frnd(39200);\n  this.lowPassSweep = rndr(0.012, 82);\n  if (this.lowPassFrequency < 35 && this.lowPassSweep < 0.802)\n    this.lowPassSweep = 1 - this.lowPassSweep;\n  this.highPassFrequency = 39200 * pow(frnd(1), 5);\n  this.highPassSweep = 555718 * pow(rndr(-1, 1), 5);\n  this.flangerOffset = 0.023 * cube(frnd(2) - 1);\n  this.flangerSweep = cube(frnd(2) - 1);\n  this.retriggerRate = frnd(1378);\n  this.arpeggioDelay = frnd(1.81);\n  this.arpeggioFactor = rndr(0.09, 10);\n  return this;\n};\n\nKnobs.prototype.tone = function () {\n  this.shape = SINE;\n  this.frequency = 440;\n  this.attack = 0;\n  this.sustain = 1;\n  this.decay = 0;\n  return this;\n};\n\nvar genners = 'pickupCoin,laserShoot,explosion,powerUp,hitHurt,jump,blipSelect,random,tone'.split(',');\nfor (var i = 0; i < genners.length; ++i) {\n  (function (g) {\n    if (!Knobs.prototype[g])\n      Knobs.prototype[g] = function () {\n        return this.translate(new Params()[g]());\n      }\n  })(genners[i]);\n}\n",
      "mode": "100644"
    }
  },
  "distribution": {
    "demo": {
      "path": "demo",
      "content": "\nvar PARAMS;\nvar SOUND;\nvar SOUND_VOL = 0.25;\nvar SAMPLE_RATE = 44100;\nvar SAMPLE_SIZE = 8;\n\nParams.prototype.query = function () {\n  var result = \"\";\n  var that = this;\n  $.each(this, function (key,value) {\n    if (that.hasOwnProperty(key))\n      result += \"&\" + key + \"=\" + value;\n  });\n  return result.substring(1);\n};\n\nfunction gen(fx) {\n  PARAMS = new Params();\n  PARAMS.sound_vol = SOUND_VOL;\n  PARAMS.sample_rate = SAMPLE_RATE;\n  PARAMS.sample_size = SAMPLE_SIZE;\n  PARAMS[fx]();\n  $(\"#wav\").text(fx + \".wav\");\n  updateUi();\n  play();\n}\n\nfunction mut() {\n  PARAMS.mutate();\n  updateUi();\n  play();\n}\n\nfunction play(noregen) {\n  setTimeout(function () {\n    var audio = new Audio();\n    if (!noregen) {\n      SOUND = new SoundEffect(PARAMS).generate();\n      $(\"#file_size\").text(Math.round(SOUND.wav.length / 1024) + \"kB\");\n      $(\"#num_samples\").text(SOUND.header.subChunk2Size /\n                             (SOUND.header.bitsPerSample >> 3));\n      $(\"#clipping\").text(SOUND.clipping);\n    }\n    audio.src = SOUND.dataURI;\n    $(\"#wav\").attr(\"href\", SOUND.dataURI);\n    $(\"#sfx\").attr(\"href\", \"sfx.wav?\" + PARAMS.query());\n    audio.play();\n  }, 0);\n}\n\nfunction disenable() {\n  var duty = PARAMS.wave_type == SQUARE || PARAMS.wave_type == SAWTOOTH;\n  $(\"#p_duty\").slider(\"option\", \"disabled\", !duty);\n  $(\"#p_duty_ramp\").slider(\"option\", \"disabled\", !duty);\n}\n\nfunction updateUi() {\n  $.each(PARAMS, function (param, value) {\n    if (param == \"wave_type\") {\n      $(\"#shape input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else if (param == \"sample_rate\") {\n      $(\"#hz input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else if (param == \"sample_size\") {\n      $(\"#bits input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else {\n      var id = \"#\" + param;\n      $(id).slider(\"value\", 1000 * value);\n      $(id).each(function(){convert(this, PARAMS[this.id]);});\n    }\n  });\n  disenable();\n}\n\n\n$(function() {\n  $(\"#shape\").buttonset();\n  $(\"#hz\").buttonset();\n  $(\"#bits\").buttonset();\n  $(\"#shape input:radio\").change(function (event) {\n    PARAMS.wave_type = parseInt(event.target.value);\n    disenable();\n    play();\n  });\n  $(\"#hz input:radio\").change(function (event) {\n    SAMPLE_RATE = PARAMS.sample_rate = parseInt(event.target.value);\n    play();\n  });\n  $(\"#bits input:radio\").change(function (event) {\n    SAMPLE_SIZE = PARAMS.sample_size = parseInt(event.target.value);\n    play();\n  });\n  $(\"button\").button();\n  $(\".slider\").slider({\n    value: 1000,\n    min: 0,\n    max: 1000,\n    slide: function (event, ui) {\n      convert(event.target, ui.value / 1000.0);\n    },\n    change: function(event, ui) {\n      if (event.originalEvent) {\n        PARAMS[event.target.id] = ui.value / 1000.0;\n        convert(event.target, PARAMS[event.target.id]);\n        play();\n      }\n    }\n  });\n  $(\".slider\").filter(\".signed\").\n    slider(\"option\", \"min\", -1000).\n    slider(\"value\", 0);\n  $('.slider').each(function () {\n      var is = this.id;\n      if (!$('label[for=\"' + is + '\"]').length)\n        $(this).parent().parent().find('th').append($('<label>',\n                                                      {for: is}));\n    });\n\n  var UNITS = {\n    p_env_attack:  function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n    p_env_sustain: function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n    p_env_punch:   function (v) { return '+' + (v * 100).toPrecision(4) + '%'},\n    p_env_decay:   function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n\n    p_base_freq:  'Hz',\n    p_freq_limit: 'Hz',\n    p_freq_ramp:  function (v) {\n      return (44100*Math.log(v)/Math.log(0.5)).toPrecision(4) + ' 8va/sec'; },\n    p_freq_dramp: function (v) {\n      return (v*44100 / Math.pow(2, -44101/44100)).toPrecision(4) +\n        ' 8va/sec^2?'; },\n\n    p_vib_speed:    function (v) { return v === 0 ? 'OFF' :\n                                   (441000/64 * v).toPrecision(4) + ' Hz'},\n    p_vib_strength: function (v) { return v === 0 ? 'OFF' :\n                                   '&plusmn; ' + (v*100).toPrecision(4) + '%' },\n\n    p_arp_mod:   function (v) { return ((v === 1) ? 'OFF' :\n                                        'x ' + (1/v).toPrecision(4)) },\n    p_arp_speed: function (v) { return (v === 0 ? 'OFF' :\n                                        (v / 44100).toPrecision(4) +' sec') },\n\n    p_duty:      function (v) { return (100 * v).toPrecision(4) + '%'; },\n    p_duty_ramp: function (v) { return (8 * 44100 * v).toPrecision(4) +'%/sec'},\n\n    p_repeat_speed: function (v) { return v === 0 ? 'OFF' :\n                                   (44100/v).toPrecision(4) + ' Hz' },\n\n    p_pha_offset: function (v) { return v === 0 ? 'OFF' :\n                                 (1000*v/44100).toPrecision(4) + ' msec' },\n    // Not so sure about this:\n    p_pha_ramp:   function (v) { return v === 0 ? 'OFF' :\n                 (1000*v).toPrecision(4) + ' msec/sec' },\n\n    p_lpf_freq:   function (v) {\n      return (v === 0.1) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },\n    p_lpf_ramp:  function (v) {  if (v === 1) return 'OFF';\n      return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },\n    p_lpf_resonance: function (v) { return (100*(1-v*0.11)).toPrecision(4)+'%';},\n\n    p_hpf_freq:   function (v) {\n      return (v === 0) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },\n    p_hpf_ramp: function (v) {  if (v === 1) return 'OFF';\n      return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },\n\n    sound_vol: function (v) {\n      v = 10 * Math.log(v*v) / Math.log(10);\n      var sign = v >= 0 ? '+' : '';\n      return sign + v.toPrecision(4) + ' dB';\n    }\n  };\n\n  var CONVERSIONS = {\n    p_env_attack:  function (v) { return v * v * 100000.0 },\n    p_env_sustain: function (v) { return v * v * 100000.0 },\n    p_env_punch:   function (v) { return v },\n    p_env_decay:   function (v) { return v * v * 100000.0 },\n\n    p_base_freq:  function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },\n    p_freq_limit: function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },\n    p_freq_ramp:  function (v) { return 1.0 - Math.pow(v, 3.0) * 0.01 },\n    p_freq_dramp: function (v) { return -Math.pow(v, 3.0) * 0.000001 },\n\n    p_vib_speed:    function (v) { return Math.pow(v, 2.0) * 0.01 },\n    p_vib_strength: function (v) { return v * 0.5 },\n\n    p_arp_mod:   function (v) {\n      return v >= 0 ? 1.0 - Math.pow(v, 2) * 0.9 : 1.0 + Math.pow(v, 2) * 10; },\n    p_arp_speed: function (v) { return (v === 1.0) ? 0 :\n                                Math.floor(Math.pow(1.0 - v, 2.0) * 20000 +32)},\n\n    p_duty:      function (v) { return 0.5 - v * 0.5; },\n    p_duty_ramp: function (v) { return -v * 0.00005 },\n\n    p_repeat_speed: function (v) { return (v === 0) ? 0 :\n                                   Math.floor(Math.pow(1-v, 2) * 20000) + 32 },\n\n    p_pha_offset: function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2)*1020 },\n    p_pha_ramp:   function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2) },\n\n    p_lpf_freq:   function (v) { return Math.pow(v, 3) * 0.1 },\n    p_lpf_ramp:   function (v) { return 1.0 + v * 0.0001 },\n    p_lpf_resonance: function (v) { return 5.0 / (1.0 + Math.pow(v, 2) * 20) }, // * (0.01 + fltw);\n\n    p_hpf_freq: function (v) { return Math.pow(v, 2) * 0.1 },\n    p_hpf_ramp: function (v) { return 1.0 + v * 0.0003 },\n\n    sound_vol: function (v) { return Math.exp(v) - 1; }\n  };\n  for (var p in CONVERSIONS) {\n    var control = $('#' + p)[0];\n    control.convert = CONVERSIONS[p];\n    control.units = UNITS[p];\n  }\n\n  gen(\"pickupCoin\");\n});\n\nfunction convert(control, v) {\n  if (control.convert) {\n    v = control.convert(v);\n    control.convertedValue = v;\n    if (typeof control.units === 'function')\n      v = control.units(v);\n    else\n      v = v.toPrecision(4) + ' ' + control.units;\n    $('label[for=\"' + control.id + '\"]').html(v);\n  }\n}\n",
      "type": "blob"
    },
    "main": {
      "path": "main",
      "content": "(function() {\n  var ApplicationTemplate, Params, SoundEffect, audio, createAndPlay, params;\n\n  ApplicationTemplate = require(\"./templates/application\");\n\n  global.SFXR = require(\"./sfxr\");\n\n  Params = SFXR.Params, SoundEffect = SFXR.SoundEffect;\n\n  params = new Params;\n\n  audio = document.createElement(\"audio\");\n\n  createAndPlay = function(type) {\n    var sfx;\n    params = new Params;\n    params[type]();\n    sfx = new SoundEffect(params).generate();\n    audio.src = sfx.dataURI;\n    return audio.play();\n  };\n\n  document.body.appendChild(ApplicationTemplate({\n    coin: function() {\n      return createAndPlay(\"pickupCoin\");\n    },\n    laser: function() {\n      return createAndPlay(\"laserShoot\");\n    },\n    explosion: function() {\n      return createAndPlay(\"explosion\");\n    },\n    powerUp: function() {\n      return createAndPlay(\"powerUp\");\n    },\n    hit: function() {\n      return createAndPlay(\"hitHurt\");\n    },\n    jump: function() {\n      return createAndPlay(\"jump\");\n    },\n    blip: function() {\n      return createAndPlay(\"blipSelect\");\n    },\n    tone: function() {\n      return createAndPlay(\"tone\");\n    }\n  }));\n\n}).call(this);\n",
      "type": "blob"
    },
    "riffwave": {
      "path": "riffwave",
      "content": "/*\n * RIFFWAVE.js v0.03 - Audio encoder for HTML5 <audio> elements.\n * Copyright (C) 2011 Pedro Ladaria <pedro.ladaria at Gmail dot com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * version 2 as published by the Free Software Foundation.\n * The full license is available at http://www.gnu.org/licenses/gpl.html\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n *\n * Changelog:\n *\n * 0.01 - First release\n * 0.02 - New faster base64 encoding\n * 0.03 - Blob URLs\n *\n */\n\nvar RIFFWAVE = function(data) {\n\n  this.data = [];        // Byte array containing audio samples\n  this.wav = [];         // Array containing the generated wave file\n  this.dataURI = '';     // http://en.wikipedia.org/wiki/Data_URI_scheme\n\n  this.header = {                         // OFFS SIZE NOTES\n    chunkId      : [0x52,0x49,0x46,0x46], // 0    4    \"RIFF\" = 0x52494646\n    chunkSize    : 0,                     // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)\n    format       : [0x57,0x41,0x56,0x45], // 8    4    \"WAVE\" = 0x57415645\n    subChunk1Id  : [0x66,0x6d,0x74,0x20], // 12   4    \"fmt \" = 0x666d7420\n    subChunk1Size: 16,                    // 16   4    16 for PCM\n    audioFormat  : 1,                     // 20   2    PCM = 1\n    numChannels  : 1,                     // 22   2    Mono = 1, Stereo = 2, etc.\n    sampleRate   : 8000,                  // 24   4    8000, 44100, etc\n    byteRate     : 0,                     // 28   4    SampleRate*NumChannels*BitsPerSample/8\n    blockAlign   : 0,                     // 32   2    NumChannels*BitsPerSample/8\n    bitsPerSample: 8,                     // 34   2    8 bits = 8, 16 bits = 16, etc...\n    subChunk2Id  : [0x64,0x61,0x74,0x61], // 36   4    \"data\" = 0x64617461\n    subChunk2Size: 0                      // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8\n  };\n\n  function u32ToArray(i) { return [i&0xFF, (i>>8)&0xFF, (i>>16)&0xFF, (i>>24)&0xFF]; }\n\n  function u16ToArray(i) { return [i&0xFF, (i>>8)&0xFF]; }\n\n  this.Make = function(data) {\n    if (data instanceof Array) this.data = data;\n    this.header.byteRate = (this.header.sampleRate * this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.blockAlign = (this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.subChunk2Size = this.data.length;\n    this.header.chunkSize = 36 + this.header.subChunk2Size;\n\n    this.wav = this.header.chunkId.concat(\n      u32ToArray(this.header.chunkSize),\n      this.header.format,\n      this.header.subChunk1Id,\n      u32ToArray(this.header.subChunk1Size),\n      u16ToArray(this.header.audioFormat),\n      u16ToArray(this.header.numChannels),\n      u32ToArray(this.header.sampleRate),\n      u32ToArray(this.header.byteRate),\n      u16ToArray(this.header.blockAlign),\n      u16ToArray(this.header.bitsPerSample),\n      this.header.subChunk2Id,\n      u32ToArray(this.header.subChunk2Size),\n      this.data\n    );\n\n    var dat = Uint8Array.from(this.wav);\n    var blob = new Blob([dat], {type: \"audio/wav\"});\n    var url = URL.createObjectURL(blob);\n    this.dataURI = url;\n  };\n\n  if (data instanceof Array) this.Make(data);\n\n}; // end RIFFWAVE\n\n\nif (typeof exports != 'undefined')  // For node.js\n  exports.RIFFWAVE = RIFFWAVE;\n",
      "type": "blob"
    },
    "sfxr": {
      "path": "sfxr",
      "content": "// Wave shapes\nvar SQUARE = 0;\nvar SAWTOOTH = 1;\nvar SINE = 2;\nvar NOISE = 3;\n\n// Playback volume\nvar masterVolume = 1;\n\nvar OVERSAMPLING = 8;\n\n\nfunction sqr(x) { return x * x }\nfunction cube(x) { return x * x * x }\nfunction sign(x) { return x < 0 ? -1 : 1 }\nfunction log(x, b) { return Math.log(x) / Math.log(b); }\nvar pow = Math.pow;\n\n// Sound generation parameters are on [0,1] unless noted SIGNED & thus\n// on [-1,1]\nfunction Params() {\n  this.oldParams = true;  // Note what structure this is\n\n  // Wave shape\n  this.wave_type = SQUARE;\n\n  // Envelope\n  this.p_env_attack = 0;   // Attack time\n  this.p_env_sustain = 0.3;  // Sustain time\n  this.p_env_punch = 0;    // Sustain punch\n  this.p_env_decay = 0.4;    // Decay time\n\n  // Tone\n  this.p_base_freq = 0.3;    // Start frequency\n  this.p_freq_limit = 0;   // Min frequency cutoff\n  this.p_freq_ramp = 0;    // Slide (SIGNED)\n  this.p_freq_dramp = 0;   // Delta slide (SIGNED)\n  // Vibrato\n  this.p_vib_strength = 0; // Vibrato depth\n  this.p_vib_speed = 0;    // Vibrato speed\n\n  // Tonal change\n  this.p_arp_mod = 0;      // Change amount (SIGNED)\n  this.p_arp_speed = 0;    // Change speed\n\n  // Square wave duty (proportion of time signal is high vs. low)\n  this.p_duty = 0;         // Square duty\n  this.p_duty_ramp = 0;    // Duty sweep (SIGNED)\n\n  // Repeat\n  this.p_repeat_speed = 0; // Repeat speed\n\n  // Flanger\n  this.p_pha_offset = 0;   // Flanger offset (SIGNED)\n  this.p_pha_ramp = 0;     // Flanger sweep (SIGNED)\n\n  // Low-pass filter\n  this.p_lpf_freq = 1;     // Low-pass filter cutoff\n  this.p_lpf_ramp = 0;     // Low-pass filter cutoff sweep (SIGNED)\n  this.p_lpf_resonance = 0;// Low-pass filter resonance\n  // High-pass filter\n  this.p_hpf_freq = 0;     // High-pass filter cutoff\n  this.p_hpf_ramp = 0;     // High-pass filter cutoff sweep (SIGNED)\n\n  // Sample parameters\n  this.sound_vol = 0.5;\n  this.sample_rate = 44100;\n  this.sample_size = 8;\n}\n\n\nfunction frnd(range) {\n  return Math.random() * range;\n}\n\nfunction rndr(from, to) {\n  return Math.random() * (to - from) + from;\n}\n\nfunction rnd(max) {\n  return Math.floor(Math.random() * (max + 1));\n}\n\n\n// These functions roll up random sounds appropriate to various\n// typical game events:\n\n\nParams.prototype.pickupCoin = function () {\n  this.p_base_freq = 0.4 + frnd(0.5);\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.1);\n  this.p_env_decay = 0.1 + frnd(0.4);\n  this.p_env_punch = 0.3 + frnd(0.3);\n  if (rnd(1)) {\n    this.p_arp_speed = 0.5 + frnd(0.2);\n    this.p_arp_mod = 0.2 + frnd(0.4);\n  }\n  return this;\n};\n\n\nParams.prototype.laserShoot = function () {\n  this.wave_type = rnd(2);\n  if(this.wave_type === SINE && rnd(1))\n    this.wave_type = rnd(1);\n  if (rnd(2) === 0) {\n    this.p_base_freq = 0.3 + frnd(0.6);\n    this.p_freq_limit = frnd(0.1);\n    this.p_freq_ramp = -0.35 - frnd(0.3);\n  } else {\n    this.p_base_freq = 0.5 + frnd(0.5);\n    this.p_freq_limit = this.p_base_freq - 0.2 - frnd(0.6);\n    if (this.p_freq_limit < 0.2) this.p_freq_limit = 0.2;\n    this.p_freq_ramp = -0.15 - frnd(0.2);\n  }\n  if (this.wave_type === SAWTOOTH)\n    this.p_duty = 1;\n  if (rnd(1)) {\n    this.p_duty = frnd(0.5);\n    this.p_duty_ramp = frnd(0.2);\n  } else {\n    this.p_duty = 0.4 + frnd(0.5);\n    this.p_duty_ramp = -frnd(0.7);\n  }\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.2);\n  this.p_env_decay = frnd(0.4);\n  if (rnd(1))\n    this.p_env_punch = frnd(0.3);\n  if (rnd(2) === 0) {\n    this.p_pha_offset = frnd(0.2);\n    this.p_pha_ramp = -frnd(0.2);\n  }\n  //if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n\n  return this;\n};\n\n\nParams.prototype.explosion = function () {\n  this.wave_type = NOISE;\n  if (rnd(1)) {\n    this.p_base_freq = sqr(0.1 + frnd(0.4));\n    this.p_freq_ramp = -0.1 + frnd(0.4);\n  } else {\n    this.p_base_freq = sqr(0.2 + frnd(0.7));\n    this.p_freq_ramp = -0.2 - frnd(0.2);\n  }\n  if (rnd(4) === 0)\n    this.p_freq_ramp = 0;\n  if (rnd(2) === 0)\n    this.p_repeat_speed = 0.3 + frnd(0.5);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.3);\n  this.p_env_decay = frnd(0.5);\n  if (rnd(1)) {\n    this.p_pha_offset = -0.3 + frnd(0.9);\n    this.p_pha_ramp = -frnd(0.3);\n  }\n  this.p_env_punch = 0.2 + frnd(0.6);\n  if (rnd(1)) {\n    this.p_vib_strength = frnd(0.7);\n    this.p_vib_speed = frnd(0.6);\n  }\n  if (rnd(2) === 0) {\n    this.p_arp_speed = 0.6 + frnd(0.3);\n    this.p_arp_mod = 0.8 - frnd(1.6);\n  }\n\n  return this;\n};\n\n\nParams.prototype.powerUp = function () {\n  if (rnd(1)) {\n    this.wave_type = SAWTOOTH;\n    this.p_duty = 1;\n  } else {\n    this.p_duty = frnd(0.6);\n  }\n  this.p_base_freq = 0.2 + frnd(0.3);\n  if (rnd(1)) {\n    this.p_freq_ramp = 0.1 + frnd(0.4);\n    this.p_repeat_speed = 0.4 + frnd(0.4);\n  } else {\n    this.p_freq_ramp = 0.05 + frnd(0.2);\n    if (rnd(1)) {\n      this.p_vib_strength = frnd(0.7);\n      this.p_vib_speed = frnd(0.6);\n    }\n  }\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.4);\n  this.p_env_decay = 0.1 + frnd(0.4);\n\n  return this;\n};\n\n\nParams.prototype.hitHurt = function () {\n  this.wave_type = rnd(2);\n  if (this.wave_type === SINE)\n    this.wave_type = NOISE;\n  if (this.wave_type === SQUARE)\n    this.p_duty = frnd(0.6);\n  if (this.wave_type === SAWTOOTH)\n    this.p_duty = 1;\n  this.p_base_freq = 0.2 + frnd(0.6);\n  this.p_freq_ramp = -0.3 - frnd(0.4);\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.1);\n  this.p_env_decay = 0.1 + frnd(0.2);\n  if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n  return this;\n};\n\n\nParams.prototype.jump = function () {\n  this.wave_type = SQUARE;\n  this.p_duty = frnd(0.6);\n  this.p_base_freq = 0.3 + frnd(0.3);\n  this.p_freq_ramp = 0.1 + frnd(0.2);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.3);\n  this.p_env_decay = 0.1 + frnd(0.2);\n  if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n  if (rnd(1))\n    this.p_lpf_freq = 1 - frnd(0.6);\n  return this;\n};\n\n\nParams.prototype.blipSelect = function () {\n  this.wave_type = rnd(1);\n  if (this.wave_type === SQUARE)\n    this.p_duty = frnd(0.6);\n  else\n    this.p_duty = 1;\n  this.p_base_freq = 0.2 + frnd(0.4);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.1);\n  this.p_env_decay = frnd(0.2);\n  this.p_hpf_freq = 0.1;\n  return this;\n};\n\n\nParams.prototype.tone = function () {\n  this.wave_type = SINE;\n  this.p_base_freq = 0.35173364; // 440 Hz\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.6641; // 1 sec\n  this.p_env_decay = 0;\n  this.p_env_punch = 0;\n  return this;\n};\n\n\nParams.prototype.mutate = function () {\n  if (rnd(1)) this.p_base_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_freq_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_freq_dramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_duty += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_duty_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_strength += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_delay += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_attack += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_sustain += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_decay += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_punch += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_resonance += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_hpf_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_hpf_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_pha_offset += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_pha_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_repeat_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_arp_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_arp_mod += frnd(0.1) - 0.05;\n};\n\n\nParams.prototype.random = function () {\n  if (rnd(1))\n    this.p_base_freq = cube(frnd(2) - 1) + 0.5;\n  else\n    this.p_base_freq = sqr(frnd(1));\n  this.p_freq_limit = 0;\n  this.p_freq_ramp = Math.pow(frnd(2) - 1, 5);\n  if (this.p_base_freq > 0.7 && this.p_freq_ramp > 0.2)\n    this.p_freq_ramp = -this.p_freq_ramp;\n  if (this.p_base_freq < 0.2 && this.p_freq_ramp < -0.05)\n    this.p_freq_ramp = -this.p_freq_ramp;\n  this.p_freq_dramp = Math.pow(frnd(2) - 1, 3);\n  this.p_duty = frnd(2) - 1;\n  this.p_duty_ramp = Math.pow(frnd(2) - 1, 3);\n  this.p_vib_strength = Math.pow(frnd(2) - 1, 3);\n  this.p_vib_speed = rndr(-1, 1);\n  this.p_env_attack = cube(rndr(-1, 1));\n  this.p_env_sustain = sqr(rndr(-1, 1));\n  this.p_env_decay = rndr(-1, 1);\n  this.p_env_punch = Math.pow(frnd(0.8), 2);\n  if (this.p_env_attack + this.p_env_sustain + this.p_env_decay < 0.2) {\n    this.p_env_sustain += 0.2 + frnd(0.3);\n    this.p_env_decay += 0.2 + frnd(0.3);\n  }\n  this.p_lpf_resonance = rndr(-1, 1);\n  this.p_lpf_freq = 1 - Math.pow(frnd(1), 3);\n  this.p_lpf_ramp = Math.pow(frnd(2) - 1, 3);\n  if (this.p_lpf_freq < 0.1 && this.p_lpf_ramp < -0.05)\n    this.p_lpf_ramp = -this.p_lpf_ramp;\n  this.p_hpf_freq = Math.pow(frnd(1), 5);\n  this.p_hpf_ramp = Math.pow(frnd(2) - 1, 5);\n  this.p_pha_offset = Math.pow(frnd(2) - 1, 3);\n  this.p_pha_ramp = Math.pow(frnd(2) - 1, 3);\n  this.p_repeat_speed = frnd(2) - 1;\n  this.p_arp_speed = frnd(2) - 1;\n  this.p_arp_mod = frnd(2) - 1;\n  return this;\n};\n\n\nfunction SoundEffect(ps) {\n  if (ps.oldParams)\n    this.initFromUI(ps);\n  else\n    this.init(ps);\n}\n\n\nSoundEffect.prototype.initFromUI = function (ps) {\n  //\n  // Convert user-facing parameter values to units usable by the sound\n  // generator\n  //\n\n  this.initForRepeat = function() {\n    this.elapsedSinceRepeat = 0;\n\n    this.period = 100 / (ps.p_base_freq * ps.p_base_freq + 0.001);\n    this.periodMax = 100 / (ps.p_freq_limit * ps.p_freq_limit + 0.001);\n    this.enableFrequencyCutoff = (ps.p_freq_limit > 0);\n    this.periodMult = 1 - Math.pow(ps.p_freq_ramp, 3) * 0.01;\n    this.periodMultSlide = -Math.pow(ps.p_freq_dramp, 3) * 0.000001;\n\n    this.dutyCycle = 0.5 - ps.p_duty * 0.5;\n    this.dutyCycleSlide = -ps.p_duty_ramp * 0.00005;\n\n    if (ps.p_arp_mod >= 0)\n      this.arpeggioMultiplier = 1 - Math.pow(ps.p_arp_mod, 2) * .9;\n    else\n      this.arpeggioMultiplier = 1 + Math.pow(ps.p_arp_mod, 2) * 10;\n    this.arpeggioTime = Math.floor(Math.pow(1 - ps.p_arp_speed, 2) * 20000 + 32);\n    if (ps.p_arp_speed === 1)\n      this.arpeggioTime = 0;\n  }\n\n  this.initForRepeat();  // First time through, this is a bit of a misnomer\n\n  // Waveform shape\n  this.waveShape = parseInt(ps.wave_type);\n\n  // Filter\n  this.fltw = Math.pow(ps.p_lpf_freq, 3) * 0.1;\n  this.enableLowPassFilter = (ps.p_lpf_freq != 1);\n  this.fltw_d = 1 + ps.p_lpf_ramp * 0.0001;\n  this.fltdmp = 5 / (1 + Math.pow(ps.p_lpf_resonance, 2) * 20) *\n    (0.01 + this.fltw);\n  if (this.fltdmp > 0.8) this.fltdmp=0.8;\n  this.flthp = Math.pow(ps.p_hpf_freq, 2) * 0.1;\n  this.flthp_d = 1 + ps.p_hpf_ramp * 0.0003;\n\n  // Vibrato\n  this.vibratoSpeed = Math.pow(ps.p_vib_speed, 2) * 0.01;\n  this.vibratoAmplitude = ps.p_vib_strength * 0.5;\n\n  // Envelope\n  this.envelopeLength = [\n    Math.floor(ps.p_env_attack * ps.p_env_attack * 100000),\n    Math.floor(ps.p_env_sustain * ps.p_env_sustain * 100000),\n    Math.floor(ps.p_env_decay * ps.p_env_decay * 100000)\n  ];\n  this.envelopePunch = ps.p_env_punch;\n\n  // Flanger\n  this.flangerOffset = Math.pow(ps.p_pha_offset, 2) * 1020;\n  if (ps.p_pha_offset < 0) this.flangerOffset = -this.flangerOffset;\n  this.flangerOffsetSlide = Math.pow(ps.p_pha_ramp, 2) * 1;\n  if (ps.p_pha_ramp < 0) this.flangerOffsetSlide = -this.flangerOffsetSlide;\n\n  // Repeat\n  this.repeatTime = Math.floor(Math.pow(1 - ps.p_repeat_speed, 2) * 20000\n                               + 32);\n  if (ps.p_repeat_speed === 0)\n    this.repeatTime = 0;\n\n  this.gain = Math.exp(ps.sound_vol) - 1;\n\n  this.sampleRate = ps.sample_rate;\n  this.bitsPerChannel = ps.sample_size;\n\n  console.log(this);\n};\n\n\nSoundEffect.prototype.init = function (ps) {\n  //\n  // Convert user-facing parameter values to units usable by the sound\n  // generator\n  //\n\n  this.initForRepeat = function() {\n    this.elapsedSinceRepeat = 0;\n\n    this.period = OVERSAMPLING * 44100 / ps.frequency;\n    this.periodMax = OVERSAMPLING * 44100 / ps.frequencyMin;\n    this.enableFrequencyCutoff = (ps.frequencyMin > 0);\n    this.periodMult = Math.pow(.5, ps.frequencySlide / 44100);\n    this.periodMultSlide = ps.frequencySlideSlide * Math.pow(2, -44101/44100)\n      / 44100;\n\n    this.dutyCycle = ps.dutyCycle;\n    this.dutyCycleSlide = ps.dutyCycleSweep / (OVERSAMPLING * 44100);\n\n    this.arpeggioMultiplier = 1 / ps.arpeggioFactor;\n    this.arpeggioTime = ps.arpeggioDelay * 44100;\n  }\n  this.initForRepeat();  // First time through, this is a bit of a misnomer\n\n  // Waveform shape\n  this.waveShape = ps.shape;\n\n  // Low pass filter\n  this.fltw = ps.lowPassFrequency / (OVERSAMPLING * 44100 + ps.lowPassFrequency);\n  this.enableLowPassFilter = ps.lowPassFrequency < 44100;\n  this.fltw_d = Math.pow(ps.lowPassSweep, 1/44100);\n  this.fltdmp = (1 - ps.lowPassResonance) * 9 * (.01 + this.fltw);\n\n  // High pass filter\n  this.flthp = ps.highPassFrequency / (OVERSAMPLING * 44100 + ps.highPassFrequency);\n  this.flthp_d = Math.pow(ps.highPassSweep, 1/44100);\n\n  // Vibrato\n  this.vibratoSpeed = ps.vibratoRate * 64 / 44100 / 10;\n  this.vibratoAmplitude = ps.vibratoDepth;\n\n  // Envelope\n  this.envelopeLength = [\n    Math.floor(ps.attack * 44100),\n    Math.floor(ps.sustain * 44100),\n    Math.floor(ps.decay * 44100)\n  ];\n  this.envelopePunch = ps.punch;\n\n  // Flanger\n  this.flangerOffset = ps.flangerOffset * 44100;\n  this.flangerOffsetSlide = ps.flangerSweep;\n\n  // Repeat\n  this.repeatTime = ps.retriggerRate ? 1 / (44100 * ps.retriggerRate) : 0;\n\n  // Gain\n  this.gain = Math.sqrt(Math.pow(10, ps.gain/10));\n\n  this.sampleRate = ps.sampleRate;\n  this.bitsPerChannel = ps.sampleSize;\n};\n\n\nSoundEffect.prototype.generate = function () {\n  var fltp = 0;\n  var fltdp = 0;\n  var fltphp = 0;\n\n  var noise_buffer = Array(32);\n  for (var i = 0; i < 32; ++i)\n    noise_buffer[i] = Math.random() * 2 - 1;\n\n  var envelopeStage = 0;\n  var envelopeElapsed = 0;\n\n  var vibratoPhase = 0;\n\n  var phase = 0;\n  var ipp = 0;\n  var flanger_buffer = Array(1024);\n  for (var i = 0; i < 1024; ++i)\n    flanger_buffer[i] = 0;\n\n  var num_clipped = 0;\n\n  var buffer = [];\n\n  var sample_sum = 0;\n  var num_summed = 0;\n  var summands = Math.floor(44100 / this.sampleRate);\n\n  for(var t = 0; ; ++t) {\n\n    // Repeats\n    if (this.repeatTime != 0 && ++this.elapsedSinceRepeat >= this.repeatTime)\n      this.initForRepeat();\n\n    // Arpeggio (single)\n    if(this.arpeggioTime != 0 && t >= this.arpeggioTime) {\n      this.arpeggioTime = 0;\n      this.period *= this.arpeggioMultiplier;\n    }\n\n    // Frequency slide, and frequency slide slide!\n    this.periodMult += this.periodMultSlide;\n    this.period *= this.periodMult;\n    if(this.period > this.periodMax) {\n      this.period = this.periodMax;\n      if (this.enableFrequencyCutoff)\n        break;\n    }\n\n    // Vibrato\n    var rfperiod = this.period;\n    if (this.vibratoAmplitude > 0) {\n      vibratoPhase += this.vibratoSpeed;\n      rfperiod = this.period * (1 + Math.sin(vibratoPhase) * this.vibratoAmplitude);\n    }\n    var iperiod = Math.floor(rfperiod);\n    if (iperiod < OVERSAMPLING) iperiod = OVERSAMPLING;\n\n    // Square wave duty cycle\n    this.dutyCycle += this.dutyCycleSlide;\n    if (this.dutyCycle < 0) this.dutyCycle = 0;\n    if (this.dutyCycle > 0.5) this.dutyCycle = 0.5;\n\n    // Volume envelope\n    if (++envelopeElapsed > this.envelopeLength[envelopeStage]) {\n      envelopeElapsed = 0;\n      if (++envelopeStage > 2)\n        break;\n    }\n    var env_vol;\n    var envf = envelopeElapsed / this.envelopeLength[envelopeStage];\n    if (envelopeStage === 0) {         // Attack\n      env_vol = envf;\n    } else if (envelopeStage === 1) {  // Sustain\n      env_vol = 1 + (1 - envf) * 2 * this.envelopePunch;\n    } else {                           // Decay\n      env_vol = 1 - envf;\n    }\n\n    // Flanger step\n    this.flangerOffset += this.flangerOffsetSlide;\n    var iphase = Math.abs(Math.floor(this.flangerOffset));\n    if (iphase > 1023) iphase = 1023;\n\n    if (this.flthp_d != 0) {\n      this.flthp *= this.flthp_d;\n      if (this.flthp < 0.00001)\n        this.flthp = 0.00001;\n      if (this.flthp > 0.1)\n        this.flthp = 0.1;\n    }\n\n    // 8x oversampling\n    var sample = 0;\n    for (var si = 0; si < OVERSAMPLING; ++si) {\n      var sub_sample = 0;\n      phase++;\n      if (phase >= iperiod) {\n        phase %= iperiod;\n        if (this.waveShape === NOISE)\n          for(var i = 0; i < 32; ++i)\n            noise_buffer[i] = Math.random() * 2 - 1;\n      }\n\n      // Base waveform\n      var fp = phase / iperiod;\n      if (this.waveShape === SQUARE) {\n        if (fp < this.dutyCycle)\n          sub_sample=0.5;\n        else\n          sub_sample=-0.5;\n      } else if (this.waveShape === SAWTOOTH) {\n        if (fp < this.dutyCycle)\n          sub_sample = -1 + 2 * fp/this.dutyCycle;\n        else\n          sub_sample = 1 - 2 * (fp-this.dutyCycle)/(1-this.dutyCycle);\n      } else if (this.waveShape === SINE) {\n        sub_sample = Math.sin(fp * 2 * Math.PI);\n      } else if (this.waveShape === NOISE) {\n        sub_sample = noise_buffer[Math.floor(phase * 32 / iperiod)];\n      } else {\n        throw \"ERROR: Bad wave type: \" + this.waveShape;\n      }\n\n      // Low-pass filter\n      var pp = fltp;\n      this.fltw *= this.fltw_d;\n      if (this.fltw < 0) this.fltw = 0;\n      if (this.fltw > 0.1) this.fltw = 0.1;\n      if (this.enableLowPassFilter) {\n        fltdp += (sub_sample - fltp) * this.fltw;\n        fltdp -= fltdp * this.fltdmp;\n      } else {\n        fltp = sub_sample;\n        fltdp = 0;\n      }\n      fltp += fltdp;\n\n      // High-pass filter\n      fltphp += fltp - pp;\n      fltphp -= fltphp * this.flthp;\n      sub_sample = fltphp;\n\n      // Flanger\n      flanger_buffer[ipp & 1023] = sub_sample;\n      sub_sample += flanger_buffer[(ipp - iphase + 1024) & 1023];\n      ipp = (ipp + 1) & 1023;\n\n      // final accumulation and envelope application\n      sample += sub_sample * env_vol;\n    }\n\n    // Accumulate samples appropriately for sample rate\n    sample_sum += sample;\n    if (++num_summed >= summands) {\n      num_summed = 0;\n      sample = sample_sum / summands;\n      sample_sum = 0;\n    } else {\n      continue;\n    }\n\n    sample = sample / OVERSAMPLING * masterVolume;\n    sample *= this.gain;\n\n    if (this.bitsPerChannel === 8) {\n      // Rescale [-1, 1) to [0, 256)\n      sample = Math.floor((sample + 1) * 128);\n      if (sample > 255) {\n        sample = 255;\n        ++num_clipped;\n      } else if (sample < 0) {\n        sample = 0;\n        ++num_clipped;\n      }\n      buffer.push(sample);\n    } else {\n      // Rescale [-1, 1) to [-32768, 32768)\n      sample = Math.floor(sample * (1<<15));\n      if (sample >= (1<<15)) {\n        sample = (1 << 15)-1;\n        ++num_clipped;\n      } else if (sample < -(1<<15)) {\n        sample = -(1 << 15);\n        ++num_clipped;\n      }\n      buffer.push(sample & 0xFF);\n      buffer.push((sample >> 8) & 0xFF);\n    }\n  }\n\n  var wave = new RIFFWAVE();\n  wave.header.sampleRate = this.sampleRate;\n  wave.header.bitsPerSample = this.bitsPerChannel;\n  wave.Make(buffer);\n  wave.clipping = num_clipped;\n  return wave;\n};\n\n// For node.js\nif (typeof exports !== 'undefined')  {\n  var RIFFWAVE = require(\"./riffwave\").RIFFWAVE;\n  exports.Params = Params;\n  exports.SoundEffect = SoundEffect;\n  exports.SQUARE = SQUARE;\n  exports.SAWTOOTH = SAWTOOTH;\n  exports.SINE = SINE;\n  exports.NOISE = NOISE;\n}\n",
      "type": "blob"
    },
    "style": {
      "path": "style",
      "content": "module.exports = \"button,\\np,\\n#sound_vol {\\n  width: 160px;\\n}\\n#sound_vol {\\n  margin-top: 4px;\\n}\\n#shape label {\\n  width: 80px;\\n}\\n#hz label {\\n  width: 40px;\\n}\\n#bits label {\\n  width: 80px;\\n}\\n#wav {\\n  font-weight: bold;\\n}\\ndiv {\\n  display: inline-block;\\n}\\nh1 {\\n  padding-right: 1em;\\n  padding-top: 0;\\n  margin-top: 0;\\n}\\nbody {\\n  padding-left: 2em;\\n}\\n.slider {\\n  width: 120px;\\n}\\n.ui-widget-content .ui-state-default {\\n  border-color: #f58400;\\n}\\n* {\\n  font: 10pt Helvetica;\\n}\\nh1 {\\n  font-size: 24pt;\\n}\\nh2 {\\n  font-size: 12pt;\\n}\\nbutton,\\ninput,\\nlabel {\\n  font-size: 10px;\\n}\\ndiv {\\n  vertical-align: top;\\n}\\nth {\\n  padding-left: 1em;\\n  text-align: left;\\n}\\nhr {\\n  font-size: 3px;\\n}\\n#demo-frame > div.demo {\\n  padding: 10px !important;\\n}\\n#stats td {\\n  text-align: right;\\n}\\n#stats {\\n  width: 80%;\\n}\\na {\\n  text-decoration: none;\\n  color: #00f;\\n}\\n#uncopy {\\n  margin-top: -4px;\\n  border: solid 1px #00f;\\n  border-radius: 10px;\\n  width: 8px;\\n  height: 8px;\\n  display: inline-block;\\n  text-align: center;\\n  vertical-align: middle;\\n  line-height: 6px;\\n  font-size: 10px;\\n}\\n#generators button {\\n  margin-bottom: 2px;\\n}\\n\";",
      "type": "blob"
    },
    "templates/application": {
      "path": "templates/application",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/jadelet-runtime\")(this);\n    __root.buffer(__root.element(\"application\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.coin\n      }, function(__root) {\n        __root.buffer(\"Coin\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.laser\n      }, function(__root) {\n        __root.buffer(\"Laser\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.explosion\n      }, function(__root) {\n        __root.buffer(\"Explosion\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.powerUp\n      }, function(__root) {\n        __root.buffer(\"Power Up\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.hit\n      }, function(__root) {\n        __root.buffer(\"Hit\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.jump\n      }, function(__root) {\n        __root.buffer(\"Jump\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.blip\n      }, function(__root) {\n        __root.buffer(\"Blip\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.tone\n      }, function(__root) {\n        __root.buffer(\"Tone\\n\");\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "test": {
      "path": "test",
      "content": "// For testing with node.js\n\nvar sys = require(\"util\");\n\nvar RIFFWAVE = require(\"./riffwave.js\").RIFFWAVE;\nvar sfxr = require(\"./sfxr.js\");\n\nfunction dump(that, title) {\n  if (title) console.log('\\n' + title + '\\n');\n  for (var i in that)\n    if (typeof that[i] !== 'function')\n      console.log(i, that[i]);\n}\n\nfunction diff(a, b, title) {\n  if (title) console.log('\\n' + title + '\\n');\n  for (var i in a) {\n    if (a.hasOwnProperty(i) && typeof a[i] !== 'function') {\n      if (b.hasOwnProperty(i)) {\n        if (a[i] !== b[i])\n          console.log('%', i, a[i], b[i])\n      } else\n        console.log('<', i, a[i]);\n    }\n  }\n  for (var i in b) {\n    if (b.hasOwnProperty(i) && !a.hasOwnProperty(i)) {\n      console.log('>', i, b[i]);\n    }\n  }\n}\n\n\n//var sound = new sfxr.SoundEffect((new sfxr.Params()).tone()).generate();\n/*\nvar knobs = new sfxr.Knobs({\n  shape: sfxr.SAWTOOTH,\n  attack: 0.1,\n  decay: 0.1,\n  sustain: 1,\n  frequency: 440,\n});\nvar sound = new sfxr.SoundEffect(knobs).generate();\n*/\n\n\n/*\nconsole.log(\"\\nKNOBS TONE\\n\")\nvar a, b;\ndump(a = new sfxr.SoundEffect(new sfxr.Knobs().tone()))\n\nconsole.log(\"\\nKNOBS FOR IT\\n\");\ndump(new sfxr.Knobs().tone());\n\nconsole.log(\"\\nPARAMS TONE\\n\")\ndump(b = new sfxr.SoundEffect(new sfxr.Params().tone()));\n\nconsole.log(\"\\nPARAMS FOR IT\\n\")\ndump(new sfxr.Params().tone());\n\nconsole.log('\\nDIFF <knobs >params\\n');\ndiff(a, b)\n*/\n\nvar x = 'random';\n\nvar sound = new sfxr.SoundEffect(new sfxr.Knobs()[x]()).generate();\nrequire(\"fs\").writeFile(\"./test.wav\", new Buffer(sound.wav), 'binary',\n                        function(err) {\n                          if(err) {\n                            sys.puts(err);\n                          } else {\n                            sys.puts(\"test.wav saved!\");\n                          }\n                        });\n\nvar p0 = new sfxr.Params()[x](0);\nvar p1 = new sfxr.Params()[x](1);\nvar q0 = new sfxr.Knobs().translate(p0);\nvar q1 = new sfxr.Knobs().translate(p1);\ndump(p0, 'PARAMS 0');\ndump(p1, 'PARAMS 1');\ndump(q0, 'KNOBS 0');\ndump(q1, 'KNOBS 1');\ndiff(q0, q1, 'DIFF KNOBS');\n",
      "type": "blob"
    },
    "knobs": {
      "path": "knobs",
      "content": "\nvar defaultKnobs = {\n  shape: SQUARE, // SQUARE/SAWTOOTH/SINE/NOISE\n\n  attack:  0,   // sec\n  sustain: 0.2, // sec\n  punch:   0,   // proportion\n  decay:   0.2, // sec\n\n  frequency:        1000, // Hz\n  frequencyMin:        0, // Hz\n  frequencySlide:      0, // 8va/sec\n  frequencySlideSlide: 0, // 8va/sec/sec\n\n  vibratoDepth:  0, // proportion\n  vibratoRate:  10, // Hz\n\n  arpeggioFactor: 1,   // multiple of frequency\n  arpeggioDelay:  0.1, // sec\n\n  dutyCycle:      0.5, // proportion of wavelength\n  dutyCycleSweep: 0,   // proportion/second\n\n  retriggerRate: 0, // Hz\n\n  flangerOffset: 0, // sec\n  flangerSweep:  0, // offset/sec\n\n  lowPassFrequency: 44100, // Hz\n  lowPassSweep:     1,     // ^sec\n  lowPassResonance: 0.5,   // proportion\n\n  highPassFrequency: 0, // Hz\n  highPassSweep:     0, // ^sec\n\n  gain: -10, // dB\n\n  sampleRate: 44100, // Hz\n  sampleSize: 8,     // bits per channel\n};\n\n\nfunction Knobs(settings) {\n  settings = settings||{};\n  for (var i in defaultKnobs) {\n    if (settings.hasOwnProperty(i))\n      this[i] = settings[i];\n    else\n      this[i] = defaultKnobs[i];\n  }\n}\n\n// Translate from UI-friendly settings to human-friendly ones\nKnobs.prototype.translate = function (ps) {\n  this.shape = ps.wave_type;\n\n  this.attack = sqr(ps.p_env_attack) * 100000 / 44100;\n  this.sustain = sqr(ps.p_env_sustain) * 100000 / 44100;\n  this.punch = ps.p_env_punch;\n  this.decay = sqr(ps.p_env_decay) * 100000 / 44100;\n\n  this.frequency = OVERSAMPLING * 441 * (sqr(ps.p_base_freq) + 0.001);\n  if (ps.p_freq_limit > 0)\n    this.frequencyMin = OVERSAMPLING * 441 * (sqr(ps.p_freq_limit) + 0.001);\n  else\n    this.frequencyMin = 0;\n  this.enableFrequencyCutoff = (ps.p_freq_limit > 0);\n  this.frequencySlide = 44100 * log(1 - cube(ps.p_freq_ramp) / 100, 0.5);\n  this.frequencySlideSlide = -cube(ps.p_freq_dramp) / 1000000 *\n    44100 * pow(2, 44101/44100);\n\n  this.vibratoRate = 44100 * 10 / 64 * sqr(ps.p_vib_speed) / 100;\n  this.vibratoDepth = ps.p_vib_strength / 2;\n\n  this.arpeggioFactor = 1 / ((ps.p_arp_mod >= 0) ?\n                             1 - sqr(ps.p_arp_mod) * 0.9 :\n                             1 + sqr(ps.p_arp_mod) * 10);\n  this.arpeggioDelay = ((ps.p_arp_speed === 1) ? 0 :\n                Math.floor(sqr(1 - ps.p_arp_speed) * 20000 + 32) / 44100);\n\n  this.dutyCycle = (1 - ps.p_duty) / 2;\n  this.dutyCycleSweep = OVERSAMPLING * 44100 * -ps.p_duty_ramp / 20000;\n\n  this.retriggerRate = 44100 / ((ps.p_repeat_speed === 0) ? 0 :\n                       Math.floor(sqr(1 - ps.p_repeat_speed) * 20000) + 32);\n\n  this.flangerOffset = sign(ps.p_pha_offset) *\n    sqr(ps.p_pha_offset) * 1020 / 44100;\n  this.flangerSweep = sign(ps.p_pha_ramp) * sqr(ps.p_pha_ramp);\n\n  this.enableLowPassFilter = (ps.p_lpf_freq != 1);\n  function flurp(x) { return x / (1-x) }\n  this.lowPassFrequency = ps.p_lpf_freq === 1 ? 44100 :\n    Math.round(OVERSAMPLING * 44100 * flurp(cube(ps.p_lpf_freq) / 10));\n  this.lowPassSweep = pow(1 + ps.p_lpf_ramp / 10000, 44100);\n  this.lowPassResonance = 1 - (5 / (1 + sqr(ps.p_lpf_resonance) * 20)) / 9;\n\n  this.highPassFrequency = Math.round(OVERSAMPLING * 44100 *\n                                      flurp(sqr(ps.p_hpf_freq) / 10));\n  this.highPassSweep = pow(1 + ps.p_hpf_ramp * 0.0003, 44100);\n\n  this.gain = 10 * log(sqr(Math.exp(ps.sound_vol) - 1), 10);\n\n  this.sampleRate = ps.sample_rate;\n  this.sampleSize = ps.sample_size;\n\n  return this;\n};\n\nKnobs.prototype.pickupCoin = function () {\n  this.frequency = rndr(568, 2861);\n  this.attack = 0;\n  this.sustain = frnd(0.227);\n  this.decay = rndr(0.227, 0.567);\n  this.punch = rndr(0.3, 0.6);\n  if (rnd(1)) {\n    this.arpeggioFactor = rndr(1.037, 1.479);\n    this.arpeggioDelay = rndr(0.042, 0.114);\n  }\n  return this;\n};\n\nKnobs.prototype.laserShoot = function () {\n  this.shape = rnd(2);\n  if(this.shape === SINE && rnd(1))\n    this.shape = rnd(1);\n  if (rnd(2) === 0) {\n    this.frequency = rndr(321, 2861);\n    this.frequencyMin = frnd(38.8);\n    this.frequencySlide = rndr(-27.3, -174.5);\n  } else {\n    this.frequency = rndr(321, 3532);\n    this.frequencyMin = rndr(144, 2/3 * this.frequency);\n    this.frequencySlide = rndr(-2.15, -27.27);\n  }\n  if (this.shape === SAWTOOTH)\n    this.dutyCycle = 0;\n  if (rnd(1)) {\n    this.dutyCycle = rndr(1/4, 1/2);\n    this.dutyCycleSweep = rndr(0, -3.528);\n  } else {\n    this.dutyCycle = rndr(0.05, 0.3);\n    this.dutyCycleSweep = frnd(12.35);\n  }\n  this.attack = 0;\n  this.sustain = rndr(0.02, 0.2);\n  this.decay = frnd(0.36);\n  if (rnd(1))\n    this.punch = frnd(0.3);\n  if (rnd(2) === 0) {\n    this.flangerOffset = frnd(0.001);\n    this.flangerSweep = -frnd(0.04);\n  }\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n\n  return this;\n};\n\nKnobs.prototype.explosion = function () {\n  this.shape = NOISE;\n  if (rnd(1)) {\n    this.frequency = rndr(4, 224);\n    this.frequencySlide = rndr(-0.623, 17.2);\n  } else {\n    this.frequency = rndr(9, 2318);\n    this.frequencySlide = rndr(-5.1, -40.7);\n  }\n  if (rnd(4) === 0)\n    this.frequencySlide = 0;\n  if (rnd(2) === 0)\n    this.retriggerRate = rndr(4.5, 53);\n  this.attack = 0;\n  this.sustain = rndr(0.0227, 0.363);\n  this.decay = frnd(0.567);\n  if (rnd(1)) {\n    this.flangerOffset = rndr(-0.0021, 0.0083);\n    this.flangerSweep = -frnd(0.09);\n  }\n  this.punch = 0.2 + frnd(0.6);\n  if (rnd(1)) {\n    this.vibratoDepth = frnd(0.35);\n    this.vibratoRate = frnd(24.8);\n  }\n  if (rnd(2) === 0) {\n    this.arpeggioFactor = rndr(0.135, 2.358);\n    this.arpeggioDelay = rndr(0.00526, 0.0733);\n  }\n  return this;\n};\n\n\nKnobs.prototype.powerUp = function () {\n  if (rnd(1)) {\n    this.shape = SAWTOOTH;\n    this.dutyCycle = 0;\n  } else {\n    this.dutyCycle = rndr(0.2, 0.5);\n  }\n  this.frequency = rndr(145, 886);\n  if (rnd(1)) {\n    this.frequencySlide = rndr(0.636, 79.6);\n    this.retriggerRate = rndr(6, 53);\n  } else {\n    this.frequencySlide = rndr(0.0795, 9.94);\n    if (rnd(1)) {\n      this.vibratoDepth = frnd(0.35);\n      this.vibratoRate = frnd(24.8);\n    }\n  }\n  this.attack = 0;\n  this.sustain = frnd(0.363);\n  this.decay = rndr(0.023, 0.57);\n\n  return this;\n};\n\nKnobs.prototype.hitHurt = function () {\n  this.shape = rnd(2);\n  if (this.shape === SINE)\n    this.shape = NOISE;\n  if (this.shape === SQUARE)\n    this.dutyCycle = rndr(0.2, 0.5);\n  if (this.shape === SAWTOOTH)\n    this.dutyCycle = 0;\n  this.frequency = rndr(145, 2261);\n  this.frequencySlide = rndr(-17.2, -217.9);\n  this.attack = 0;\n  this.sustain = frnd(0.023);\n  this.decay = rndr(0.023, 0.2);\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n  return this;\n};\n\nKnobs.prototype.jump = function () {\n  this.shape = SQUARE;\n  this.dutyCycle = rndr(0.2, 0.5);\n  this.frequency = rndr(321, 1274);\n  this.frequencySlide = rndr(0.64, 17.2);\n  this.attack = 0;\n  this.sustain = rndr(0.023, 0.36);\n  this.decay = rndr(0.023, 0.2);\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n  if (rnd(1))\n    this.lowPassFrequency = rndr(2272, 44100);\n  return this;\n};\n\n\nKnobs.prototype.blipSelect = function () {\n  this.shape = rnd(1);\n  if (this.shape === SQUARE)\n    this.dutyCycle = rndr(0.2, 0.5);\n  else\n    this.dutyCycle = 0;\n  this.frequency = rndr(145, 1274);\n  this.attack = 0;\n  this.sustain = rndr(0.023, 0.09);\n  this.decay = frnd(0.09);\n  this.highPassFrequency = 353;\n  return this;\n};\n\nKnobs.prototype.random = function () {\n  if (rnd(1))\n    this.frequency = rndr(885.5, 7941.5);\n  else\n    this.frequency = rndr(3.5, 3532);\n  this.frequencySlide = rndr(-633, 639);\n  if (this.frequency > 1732 && this.frequencySlide > 5)\n    this.frequencySlide = -this.frequencySlide;\n  if (this.frequency < 145 && this.frequencySlide < -0.088)\n    this.frequencySlide = -this.frequencySlide;\n  this.frequencySlideSlide = rndr(-0.88, 0.88);\n  this.dutyCycle = frnd(1);\n  this.dudyCycleSweep = rndr(-17.64, 17.64);\n  this.vibratoDepth = rndr(-0.5, 0.5);\n  this.vibratoRate = rndr(0, 69);\n  this.attack = cube(frnd(1)) * 2.26;\n  this.sustain = sqr(frnd(1)) * 2.26 + 0.09;\n  this.decay = frnd(1) * 2.26;\n  this.punch = sqr(frnd(1)) * 0.64;\n  if (this.attack + this.sustain + this.decay < 0.45) {\n    this.sustain += rndr(0.5, 1.25);\n    this.decay += rndr(0.5, 1.25);\n  }\n  this.lowPassResonance = rndr(0.444, 0.97);\n  this.lowPassFrequency = frnd(39200);\n  this.lowPassSweep = rndr(0.012, 82);\n  if (this.lowPassFrequency < 35 && this.lowPassSweep < 0.802)\n    this.lowPassSweep = 1 - this.lowPassSweep;\n  this.highPassFrequency = 39200 * pow(frnd(1), 5);\n  this.highPassSweep = 555718 * pow(rndr(-1, 1), 5);\n  this.flangerOffset = 0.023 * cube(frnd(2) - 1);\n  this.flangerSweep = cube(frnd(2) - 1);\n  this.retriggerRate = frnd(1378);\n  this.arpeggioDelay = frnd(1.81);\n  this.arpeggioFactor = rndr(0.09, 10);\n  return this;\n};\n\nKnobs.prototype.tone = function () {\n  this.shape = SINE;\n  this.frequency = 440;\n  this.attack = 0;\n  this.sustain = 1;\n  this.decay = 0;\n  return this;\n};\n\nvar genners = 'pickupCoin,laserShoot,explosion,powerUp,hitHurt,jump,blipSelect,random,tone'.split(',');\nfor (var i = 0; i < genners.length; ++i) {\n  (function (g) {\n    if (!Knobs.prototype[g])\n      Knobs.prototype[g] = function () {\n        return this.translate(new Params()[g]());\n      }\n  })(genners[i]);\n}\n",
      "type": "blob"
    },
    "lib/jadelet-runtime": {
      "path": "lib/jadelet-runtime",
      "content": "!function(n){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=n();else if(\"function\"==typeof define&&define.amd)define([],n);else{(\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:this).JadeletRuntime=n()}}(function(){return function n(e,t,r){function o(i,c){if(!t[i]){if(!e[i]){var f=\"function\"==typeof require&&require;if(!c&&f)return f(i,!0);if(u)return u(i,!0);var l=new Error(\"Cannot find module '\"+i+\"'\");throw l.code=\"MODULE_NOT_FOUND\",l}var a=t[i]={exports:{}};e[i][0].call(a.exports,function(n){var t=e[i][1][n];return o(t||n)},a,a.exports,n,e,t,r)}return t[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<r.length;i++)o(r[i]);return o}({1:[function(n,e,t){(function(){\"use strict\";var t,r,o,u,i,c,f,l,a,s,d,p,v,h,g,y,b,m,E,O,_,x,w,A,C;t=n(\"o_0\"),a=new WeakMap,s=new WeakMap,_=function(n){var e;e=s.get(n)||0,s.set(n,e+1)},O=function(n){var e;e=s.get(n)||0,--e>0?s.set(n,e):(s.delete(n),l(n))},l=function(n){var e,t;null!=(e=n.children)&&Array.prototype.forEach.call(e,l),null!=(t=a.get(n))&&t.forEach(function(e){e(),a.delete(n)})},o=function(n,e){var t;(t=a.get(n))?t.push(e):a.set(n,[e])},p=/^on(touch|animation|transition)(start|iteration|move|end|cancel)$/,h=function(n,e){return n.match(p)||n in e},A=function(n,e,t){switch(n.nodeName){case\"SELECT\":n.oninput=n.onchange=function(){var n,t,r;n=(t=this.children[this.selectedIndex]).value,r=t._value,\"function\"==typeof e&&e(r||n)},i(n,e,t,function(e){var t;n._value=e,(t=n._options)?null!=e.value?n.value=(\"function\"==typeof e.value?e.value():void 0)||e.value:n.selectedIndex=C(t,e):n.value=e});break;default:n.oninput=n.onchange=function(){\"function\"==typeof e&&e(n.value)},i(n,e,t,function(e){n.value!==e&&(n.value=e)})}},x={INPUT:{checked:function(n,e,t){return n.onchange=function(){\"function\"==typeof e&&e(n.checked)},i(n,e,t,function(e){n.checked=e})}},SELECT:{options:function(n,e,t){i(n,e,t,function(e){d(n),n._options=e,e.map(function(e,t){var r,o,u;return r=f(\"option\"),r._value=e,u=g(e)?(null!=e?e.value:void 0)||t:e.toString(),i(r,u,e,function(n){r.value=n}),o=(null!=e?e.name:void 0)||e,i(r,o,e,function(n){r.textContent=n}),n.appendChild(r),e===n._value&&(n.selectedIndex=t),r})})}}},b=function(n,e,t,r){var o,c,f;c=n.nodeName,\"value\"===t?A(n,r):(o=null!=(f=x[c])?f[t]:void 0)?o(n,r,e):t.match(/^on/)&&h(t,n)?u(n,t.substr(2),r,e):h(\"on\"+t,n)?u(n,t,r,e):i(n,r,e,function(e){null!=e&&!1!==e?n.setAttribute(t,e):n.removeAttribute(t)})},m=function(n,e,t){c(n,e,t,\"id\",function(e){var t;t=e[e.length-1],e.length?n.id=t:n.removeAttribute(\"id\")}),c(n,e,t,\"class\",function(e){n.className=e.join(\" \")}),c(n,e,t,\"style\",function(e){n.removeAttribute(\"style\"),e.forEach(function(e){return g(e)?Object.assign(n.style,e):n.setAttribute(\"style\",e)})}),Object.keys(t).forEach(function(r){b(n,e,r,t[r])})},i=function(n,e,r,u){var i;i=t(function(){u(v(e,r))}),o(n,i.releaseDependencies)},u=function(n,e,t,r){\"function\"==typeof t&&n.addEventListener(e,t.bind(r))},c=function(n,e,t,r,o){var u;null!=(u=t[r])&&(delete t[r],i(n,function(){return w(u,e)},e,o))},E=function(n,e,t){var r;r=function(e){null==e||(\"function\"==typeof e.forEach?e.forEach(r):e instanceof Node?(_(e),n.appendChild(e)):n.appendChild(document.createTextNode(e)))},i(n,function(){var n;return n=[],t.call(e,{buffer:function(t){n.push(v(t,e))},element:y}),n},e,function(e){d(n),e.forEach(r)})},y=function(n,e,t,r){var o;return o=f(n),m(o,e,t),\"SELECT\"!==o.nodeName&&E(o,e,r),o},(r=function(n){var e;return e={buffer:function(n){if(e.root)throw new Error(\"Cannot have multiple root elements\");e.root=n},element:y}}).Observable=t,r._elementCleaners=a,r._dispose=l,r.retain=_,r.release=O,e.exports=r,f=function(n){return document.createElement(n)},d=function(n){for(var e;e=n.firstChild;)n.removeChild(e),O(e)},g=function(n){return\"object\"==typeof n},C=function(n,e){return g(e)?n.indexOf(e):n.map(function(n){return n.toString()}).indexOf(e.toString())},w=function(n,e){return n.map(function(n){return v(n,e)}).reduce(function(n,e){return n.concat(v(e))},[]).filter(function(n){return null!=n})},v=function(n,e){return\"function\"==typeof n?n.call(e):n}}).call(this)},{o_0:2}],2:[function(n,e,t){(function(n){(function(){\"use strict\";var t,r,o,u,i,c,f,l,a=[].slice;e.exports=function(n,e){var u,s,d,p,v;return\"function\"==typeof(null!=n?n.observe:void 0)?n:(d=[],p=function(n){return r(d).forEach(function(e){return e(n)})},\"function\"==typeof n?(s=n,(v=function(){return i(v),n}).releaseDependencies=function(){var n;return null!=(n=v._observableDependencies)?n.forEach(function(n){return n.stopObserving(u)}):void 0},(u=function(){var t;return t=new Set,n=l(t,s,e),v.releaseDependencies(),v._observableDependencies=t,t.forEach(function(n){return n.observe(u)}),p(n)})()):(v=function(e){return arguments.length>0?n!==e&&(n=e,p(e)):i(v),n}).releaseDependencies=c,Array.isArray(n)&&([\"concat\",\"every\",\"filter\",\"forEach\",\"indexOf\",\"join\",\"lastIndexOf\",\"map\",\"reduce\",\"reduceRight\",\"slice\",\"some\"].forEach(function(e){return v[e]=function(){var t;return t=1<=arguments.length?a.call(arguments,0):[],i(v),n[e].apply(n,t)}}),[\"pop\",\"push\",\"reverse\",\"shift\",\"splice\",\"sort\",\"unshift\"].forEach(function(e){return v[e]=function(){var t,r;return t=1<=arguments.length?a.call(arguments,0):[],r=n[e].apply(n,t),p(n),r}}),t&&Object.defineProperty(v,\"length\",{get:function(){return i(v),n.length},set:function(e){var t;return t=n.length=e,p(n),t}}),o(v,{remove:function(e){var t,r;if((t=n.indexOf(e))>=0)return r=n.splice(t,1)[0],p(n),r},get:function(e){return i(v),n[e]},first:function(){return i(v),n[0]},last:function(){return i(v),n[n.length-1]},size:function(){return i(v),n.length}})),o(v,{listeners:d,observe:function(n){return d.push(n)},stopObserving:function(n){return f(d,n)},toggle:function(){return v(!n)},increment:function(e){return null==e&&(e=1),v(n+e)},decrement:function(e){return null==e&&(e=1),v(n-e)},toString:function(){return\"Observable(\"+n+\")\"}}),v)},o=Object.assign,n.OBSERVABLE_ROOT_HACK=[],i=function(e){var t;if(t=u(n.OBSERVABLE_ROOT_HACK))return t.add(e)},l=function(e,t,r){n.OBSERVABLE_ROOT_HACK.push(e);try{return t.call(r)}finally{n.OBSERVABLE_ROOT_HACK.pop()}},f=function(n,e){var t;if((t=n.indexOf(e))>=0)return n.splice(t,1)[0]},r=function(n){return n.concat([])},u=function(n){return n[n.length-1]},c=function(){};try{Object.defineProperty(function(){},\"length\",{get:c,set:c}),t=!0}catch(n){t=!1}}).call(this)}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1])(1)});\n",
      "type": "blob"
    }
  },
  "progenitor": {
    "url": "https://danielx.net/editor/"
  },
  "config": {},
  "entryPoint": "main",
  "repository": {
    "branch": "master",
    "default_branch": "master",
    "full_name": "STRd6/sfxz",
    "homepage": "http://grumdrig.github.com/jsfxr/",
    "description": "Simple and efficient sound effects generator. A port of sfxr to HTML5.",
    "html_url": "https://github.com/STRd6/sfxz",
    "url": "https://api.github.com/repos/STRd6/sfxz",
    "publishBranch": "gh-pages"
  },
  "dependencies": {}
}