(function(pkg) {
  (function() {
  var annotateSourceURL, cacheFor, circularGuard, defaultEntryPoint, fileSeparator, generateRequireFn, global, isPackage, loadModule, loadPackage, loadPath, normalizePath, publicAPI, rootModule, startsWith,
    __slice = [].slice;

  fileSeparator = '/';

  global = self;

  defaultEntryPoint = "main";

  circularGuard = {};

  rootModule = {
    path: ""
  };

  loadPath = function(parentModule, pkg, path) {
    var cache, localPath, module, normalizedPath;
    if (startsWith(path, '/')) {
      localPath = [];
    } else {
      localPath = parentModule.path.split(fileSeparator);
    }
    normalizedPath = normalizePath(path, localPath);
    cache = cacheFor(pkg);
    if (module = cache[normalizedPath]) {
      if (module === circularGuard) {
        throw "Circular dependency detected when requiring " + normalizedPath;
      }
    } else {
      cache[normalizedPath] = circularGuard;
      try {
        cache[normalizedPath] = module = loadModule(pkg, normalizedPath);
      } finally {
        if (cache[normalizedPath] === circularGuard) {
          delete cache[normalizedPath];
        }
      }
    }
    return module.exports;
  };

  normalizePath = function(path, base) {
    var piece, result;
    if (base == null) {
      base = [];
    }
    base = base.concat(path.split(fileSeparator));
    result = [];
    while (base.length) {
      switch (piece = base.shift()) {
        case "..":
          result.pop();
          break;
        case "":
        case ".":
          break;
        default:
          result.push(piece);
      }
    }
    return result.join(fileSeparator);
  };

  loadPackage = function(pkg) {
    var path;
    path = pkg.entryPoint || defaultEntryPoint;
    return loadPath(rootModule, pkg, path);
  };

  loadModule = function(pkg, path) {
    var args, content, context, dirname, file, module, program, values;
    if (!(file = pkg.distribution[path])) {
      throw "Could not find file at " + path + " in " + pkg.name;
    }
    if ((content = file.content) == null) {
      throw "Malformed package. No content for file at " + path + " in " + pkg.name;
    }
    program = annotateSourceURL(content, pkg, path);
    dirname = path.split(fileSeparator).slice(0, -1).join(fileSeparator);
    module = {
      path: dirname,
      exports: {}
    };
    context = {
      require: generateRequireFn(pkg, module),
      global: global,
      module: module,
      exports: module.exports,
      PACKAGE: pkg,
      __filename: path,
      __dirname: dirname
    };
    args = Object.keys(context);
    values = args.map(function(name) {
      return context[name];
    });
    Function.apply(null, __slice.call(args).concat([program])).apply(module, values);
    return module;
  };

  isPackage = function(path) {
    if (!(startsWith(path, fileSeparator) || startsWith(path, "." + fileSeparator) || startsWith(path, ".." + fileSeparator))) {
      return path.split(fileSeparator)[0];
    } else {
      return false;
    }
  };

  generateRequireFn = function(pkg, module) {
    var fn;
    if (module == null) {
      module = rootModule;
    }
    if (pkg.name == null) {
      pkg.name = "ROOT";
    }
    if (pkg.scopedName == null) {
      pkg.scopedName = "ROOT";
    }
    fn = function(path) {
      var otherPackage;
      if (typeof path === "object") {
        return loadPackage(path);
      } else if (isPackage(path)) {
        if (!(otherPackage = pkg.dependencies[path])) {
          throw "Package: " + path + " not found.";
        }
        if (otherPackage.name == null) {
          otherPackage.name = path;
        }
        if (otherPackage.scopedName == null) {
          otherPackage.scopedName = "" + pkg.scopedName + ":" + path;
        }
        return loadPackage(otherPackage);
      } else {
        return loadPath(module, pkg, path);
      }
    };
    fn.packageWrapper = publicAPI.packageWrapper;
    fn.executePackageWrapper = publicAPI.executePackageWrapper;
    return fn;
  };

  publicAPI = {
    generateFor: generateRequireFn,
    packageWrapper: function(pkg, code) {
      return ";(function(PACKAGE) {\n  var src = " + (JSON.stringify(PACKAGE.distribution.main.content)) + ";\n  var Require = new Function(\"PACKAGE\", \"return \" + src)({distribution: {main: {content: src}}});\n  var require = Require.generateFor(PACKAGE);\n  " + code + ";\n})(" + (JSON.stringify(pkg, null, 2)) + ");";
    },
    executePackageWrapper: function(pkg) {
      return publicAPI.packageWrapper(pkg, "require('./" + pkg.entryPoint + "')");
    },
    loadPackage: loadPackage
  };

  if (typeof exports !== "undefined" && exports !== null) {
    module.exports = publicAPI;
  } else {
    global.Require = publicAPI;
  }

  startsWith = function(string, prefix) {
    return string.lastIndexOf(prefix, 0) === 0;
  };

  cacheFor = function(pkg) {
    if (pkg.cache) {
      return pkg.cache;
    }
    Object.defineProperty(pkg, "cache", {
      value: {}
    });
    return pkg.cache;
  };

  annotateSourceURL = function(program, pkg, path) {
    return "" + program + "\n//# sourceURL=" + pkg.scopedName + "/" + path;
  };

  return publicAPI;

}).call(this);

  window.require = Require.generateFor(pkg);
})({
  "source": {
    "README.md": {
      "path": "README.md",
      "content": "SFXZ\n====\n\nA recreation of sfxr. Wish me luck!\n\n\nGoals\n-----\n\n- An embeddable synthesizer in < 1kb js (minified and gzipped)\n- A binary format for saving and loading effects in ~100 bytes\n\nStatus\n------\n",
      "mode": "100644",
      "type": "blob"
    },
    "demo.js": {
      "path": "demo.js",
      "content": "\nvar PARAMS;\nvar SOUND;\nvar SOUND_VOL = 0.25;\nvar SAMPLE_RATE = 44100;\nvar SAMPLE_SIZE = 8;\n\nParams.prototype.query = function () {\n  var result = \"\";\n  var that = this;\n  $.each(this, function (key,value) {\n    if (that.hasOwnProperty(key))\n      result += \"&\" + key + \"=\" + value;\n  });\n  return result.substring(1);\n};\n\nfunction gen(fx) {\n  PARAMS = new Params();\n  PARAMS.sound_vol = SOUND_VOL;\n  PARAMS.sample_rate = SAMPLE_RATE;\n  PARAMS.sample_size = SAMPLE_SIZE;\n  PARAMS[fx]();\n  $(\"#wav\").text(fx + \".wav\");\n  updateUi();\n  play();\n}\n\nfunction mut() {\n  PARAMS.mutate();\n  updateUi();\n  play();\n}\n\nfunction play(noregen) {\n  setTimeout(function () {\n    var audio = new Audio();\n    if (!noregen) {\n      SOUND = new SoundEffect(PARAMS).generate();\n      $(\"#file_size\").text(Math.round(SOUND.wav.length / 1024) + \"kB\");\n      $(\"#num_samples\").text(SOUND.header.subChunk2Size /\n                             (SOUND.header.bitsPerSample >> 3));\n      $(\"#clipping\").text(SOUND.clipping);\n    }\n    audio.src = SOUND.dataURI;\n    $(\"#wav\").attr(\"href\", SOUND.dataURI);\n    $(\"#sfx\").attr(\"href\", \"sfx.wav?\" + PARAMS.query());\n    audio.play();\n  }, 0);\n}\n\nfunction disenable() {\n  var duty = PARAMS.wave_type == SQUARE || PARAMS.wave_type == SAWTOOTH;\n  $(\"#p_duty\").slider(\"option\", \"disabled\", !duty);\n  $(\"#p_duty_ramp\").slider(\"option\", \"disabled\", !duty);\n}\n\nfunction updateUi() {\n  $.each(PARAMS, function (param, value) {\n    if (param == \"wave_type\") {\n      $(\"#shape input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else if (param == \"sample_rate\") {\n      $(\"#hz input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else if (param == \"sample_size\") {\n      $(\"#bits input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else {\n      var id = \"#\" + param;\n      $(id).slider(\"value\", 1000 * value);\n      $(id).each(function(){convert(this, PARAMS[this.id]);});\n    }\n  });\n  disenable();\n}\n\n\n$(function() {\n  $(\"#shape\").buttonset();\n  $(\"#hz\").buttonset();\n  $(\"#bits\").buttonset();\n  $(\"#shape input:radio\").change(function (event) {\n    PARAMS.wave_type = parseInt(event.target.value);\n    disenable();\n    play();\n  });\n  $(\"#hz input:radio\").change(function (event) {\n    SAMPLE_RATE = PARAMS.sample_rate = parseInt(event.target.value);\n    play();\n  });\n  $(\"#bits input:radio\").change(function (event) {\n    SAMPLE_SIZE = PARAMS.sample_size = parseInt(event.target.value);\n    play();\n  });\n  $(\"button\").button();\n  $(\".slider\").slider({\n    value: 1000,\n    min: 0,\n    max: 1000,\n    slide: function (event, ui) {\n      convert(event.target, ui.value / 1000.0);\n    },\n    change: function(event, ui) {\n      if (event.originalEvent) {\n        PARAMS[event.target.id] = ui.value / 1000.0;\n        convert(event.target, PARAMS[event.target.id]);\n        play();\n      }\n    }\n  });\n  $(\".slider\").filter(\".signed\").\n    slider(\"option\", \"min\", -1000).\n    slider(\"value\", 0);\n  $('.slider').each(function () {\n      var is = this.id;\n      if (!$('label[for=\"' + is + '\"]').length)\n        $(this).parent().parent().find('th').append($('<label>',\n                                                      {for: is}));\n    });\n\n  var UNITS = {\n    p_env_attack:  function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n    p_env_sustain: function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n    p_env_punch:   function (v) { return '+' + (v * 100).toPrecision(4) + '%'},\n    p_env_decay:   function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n\n    p_base_freq:  'Hz',\n    p_freq_limit: 'Hz',\n    p_freq_ramp:  function (v) {\n      return (44100*Math.log(v)/Math.log(0.5)).toPrecision(4) + ' 8va/sec'; },\n    p_freq_dramp: function (v) {\n      return (v*44100 / Math.pow(2, -44101/44100)).toPrecision(4) +\n        ' 8va/sec^2?'; },\n\n    p_vib_speed:    function (v) { return v === 0 ? 'OFF' :\n                                   (441000/64 * v).toPrecision(4) + ' Hz'},\n    p_vib_strength: function (v) { return v === 0 ? 'OFF' :\n                                   '&plusmn; ' + (v*100).toPrecision(4) + '%' },\n\n    p_arp_mod:   function (v) { return ((v === 1) ? 'OFF' :\n                                        'x ' + (1/v).toPrecision(4)) },\n    p_arp_speed: function (v) { return (v === 0 ? 'OFF' :\n                                        (v / 44100).toPrecision(4) +' sec') },\n\n    p_duty:      function (v) { return (100 * v).toPrecision(4) + '%'; },\n    p_duty_ramp: function (v) { return (8 * 44100 * v).toPrecision(4) +'%/sec'},\n\n    p_repeat_speed: function (v) { return v === 0 ? 'OFF' :\n                                   (44100/v).toPrecision(4) + ' Hz' },\n\n    p_pha_offset: function (v) { return v === 0 ? 'OFF' :\n                                 (1000*v/44100).toPrecision(4) + ' msec' },\n    // Not so sure about this:\n    p_pha_ramp:   function (v) { return v === 0 ? 'OFF' :\n                 (1000*v).toPrecision(4) + ' msec/sec' },\n\n    p_lpf_freq:   function (v) {\n      return (v === 0.1) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },\n    p_lpf_ramp:  function (v) {  if (v === 1) return 'OFF';\n      return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },\n    p_lpf_resonance: function (v) { return (100*(1-v*0.11)).toPrecision(4)+'%';},\n\n    p_hpf_freq:   function (v) {\n      return (v === 0) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },\n    p_hpf_ramp: function (v) {  if (v === 1) return 'OFF';\n      return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },\n\n    sound_vol: function (v) {\n      v = 10 * Math.log(v*v) / Math.log(10);\n      var sign = v >= 0 ? '+' : '';\n      return sign + v.toPrecision(4) + ' dB';\n    }\n  };\n\n  var CONVERSIONS = {\n    p_env_attack:  function (v) { return v * v * 100000.0 },\n    p_env_sustain: function (v) { return v * v * 100000.0 },\n    p_env_punch:   function (v) { return v },\n    p_env_decay:   function (v) { return v * v * 100000.0 },\n\n    p_base_freq:  function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },\n    p_freq_limit: function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },\n    p_freq_ramp:  function (v) { return 1.0 - Math.pow(v, 3.0) * 0.01 },\n    p_freq_dramp: function (v) { return -Math.pow(v, 3.0) * 0.000001 },\n\n    p_vib_speed:    function (v) { return Math.pow(v, 2.0) * 0.01 },\n    p_vib_strength: function (v) { return v * 0.5 },\n\n    p_arp_mod:   function (v) {\n      return v >= 0 ? 1.0 - Math.pow(v, 2) * 0.9 : 1.0 + Math.pow(v, 2) * 10; },\n    p_arp_speed: function (v) { return (v === 1.0) ? 0 :\n                                Math.floor(Math.pow(1.0 - v, 2.0) * 20000 +32)},\n\n    p_duty:      function (v) { return 0.5 - v * 0.5; },\n    p_duty_ramp: function (v) { return -v * 0.00005 },\n\n    p_repeat_speed: function (v) { return (v === 0) ? 0 :\n                                   Math.floor(Math.pow(1-v, 2) * 20000) + 32 },\n\n    p_pha_offset: function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2)*1020 },\n    p_pha_ramp:   function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2) },\n\n    p_lpf_freq:   function (v) { return Math.pow(v, 3) * 0.1 },\n    p_lpf_ramp:   function (v) { return 1.0 + v * 0.0001 },\n    p_lpf_resonance: function (v) { return 5.0 / (1.0 + Math.pow(v, 2) * 20) }, // * (0.01 + fltw);\n\n    p_hpf_freq: function (v) { return Math.pow(v, 2) * 0.1 },\n    p_hpf_ramp: function (v) { return 1.0 + v * 0.0003 },\n\n    sound_vol: function (v) { return Math.exp(v) - 1; }\n  };\n  for (var p in CONVERSIONS) {\n    var control = $('#' + p)[0];\n    control.convert = CONVERSIONS[p];\n    control.units = UNITS[p];\n  }\n\n  gen(\"pickupCoin\");\n});\n\nfunction convert(control, v) {\n  if (control.convert) {\n    v = control.convert(v);\n    control.convertedValue = v;\n    if (typeof control.units === 'function')\n      v = control.units(v);\n    else\n      v = v.toPrecision(4) + ' ' + control.units;\n    $('label[for=\"' + control.id + '\"]').html(v);\n  }\n}\n",
      "mode": "100644",
      "type": "blob"
    },
    "knobs.js": {
      "path": "knobs.js",
      "content": "// Dumping this duplicat stuff in here for now\n\nvar defaultKnobs = {\n  shape: SQUARE, // SQUARE/SAWTOOTH/SINE/NOISE\n\n  attack:  0,   // sec\n  sustain: 0.2, // sec\n  punch:   0,   // proportion\n  decay:   0.2, // sec\n\n  frequency:        1000, // Hz\n  frequencyMin:        0, // Hz\n  frequencySlide:      0, // 8va/sec\n  frequencySlideSlide: 0, // 8va/sec/sec\n\n  vibratoDepth:  0, // proportion\n  vibratoRate:  10, // Hz\n\n  arpeggioFactor: 1,   // multiple of frequency\n  arpeggioDelay:  0.1, // sec\n\n  dutyCycle:      0.5, // proportion of wavelength\n  dutyCycleSweep: 0,   // proportion/second\n\n  retriggerRate: 0, // Hz\n\n  flangerOffset: 0, // sec\n  flangerSweep:  0, // offset/sec\n\n  lowPassFrequency: 44100, // Hz\n  lowPassSweep:     1,     // ^sec\n  lowPassResonance: 0.5,   // proportion\n\n  highPassFrequency: 0, // Hz\n  highPassSweep:     0, // ^sec\n\n  gain: -10, // dB\n\n  sampleRate: 44100, // Hz\n  sampleSize: 8,     // bits per channel\n};\n\n\nfunction Knobs(settings) {\n  settings = settings||{};\n  for (var i in defaultKnobs) {\n    if (settings.hasOwnProperty(i))\n      this[i] = settings[i];\n    else\n      this[i] = defaultKnobs[i];\n  }\n}\n\n// Translate from UI-friendly settings to human-friendly ones\nKnobs.prototype.translate = function (ps) {\n  this.shape = ps.wave_type;\n\n  this.attack = sqr(ps.p_env_attack) * 100000 / 44100;\n  this.sustain = sqr(ps.p_env_sustain) * 100000 / 44100;\n  this.punch = ps.p_env_punch;\n  this.decay = sqr(ps.p_env_decay) * 100000 / 44100;\n\n  this.frequency = OVERSAMPLING * 441 * (sqr(ps.p_base_freq) + 0.001);\n  if (ps.p_freq_limit > 0)\n    this.frequencyMin = OVERSAMPLING * 441 * (sqr(ps.p_freq_limit) + 0.001);\n  else\n    this.frequencyMin = 0;\n  this.enableFrequencyCutoff = (ps.p_freq_limit > 0);\n  this.frequencySlide = 44100 * log(1 - cube(ps.p_freq_ramp) / 100, 0.5);\n  this.frequencySlideSlide = -cube(ps.p_freq_dramp) / 1000000 *\n    44100 * pow(2, 44101/44100);\n\n  this.vibratoRate = 44100 * 10 / 64 * sqr(ps.p_vib_speed) / 100;\n  this.vibratoDepth = ps.p_vib_strength / 2;\n\n  this.arpeggioFactor = 1 / ((ps.p_arp_mod >= 0) ?\n                             1 - sqr(ps.p_arp_mod) * 0.9 :\n                             1 + sqr(ps.p_arp_mod) * 10);\n  this.arpeggioDelay = ((ps.p_arp_speed === 1) ? 0 :\n                Math.floor(sqr(1 - ps.p_arp_speed) * 20000 + 32) / 44100);\n\n  this.dutyCycle = (1 - ps.p_duty) / 2;\n  this.dutyCycleSweep = OVERSAMPLING * 44100 * -ps.p_duty_ramp / 20000;\n\n  this.retriggerRate = 44100 / ((ps.p_repeat_speed === 0) ? 0 :\n                       Math.floor(sqr(1 - ps.p_repeat_speed) * 20000) + 32);\n\n  this.flangerOffset = sign(ps.p_pha_offset) *\n    sqr(ps.p_pha_offset) * 1020 / 44100;\n  this.flangerSweep = sign(ps.p_pha_ramp) * sqr(ps.p_pha_ramp);\n\n  this.enableLowPassFilter = (ps.p_lpf_freq != 1);\n  function flurp(x) { return x / (1-x) }\n  this.lowPassFrequency = ps.p_lpf_freq === 1 ? 44100 :\n    Math.round(OVERSAMPLING * 44100 * flurp(cube(ps.p_lpf_freq) / 10));\n  this.lowPassSweep = pow(1 + ps.p_lpf_ramp / 10000, 44100);\n  this.lowPassResonance = 1 - (5 / (1 + sqr(ps.p_lpf_resonance) * 20)) / 9;\n\n  this.highPassFrequency = Math.round(OVERSAMPLING * 44100 *\n                                      flurp(sqr(ps.p_hpf_freq) / 10));\n  this.highPassSweep = pow(1 + ps.p_hpf_ramp * 0.0003, 44100);\n\n  this.gain = 10 * log(sqr(Math.exp(ps.sound_vol) - 1), 10);\n\n  this.sampleRate = ps.sample_rate;\n  this.sampleSize = ps.sample_size;\n\n  return this;\n};\n\nKnobs.prototype.pickupCoin = function () {\n  this.frequency = rndr(568, 2861);\n  this.attack = 0;\n  this.sustain = frnd(0.227);\n  this.decay = rndr(0.227, 0.567);\n  this.punch = rndr(0.3, 0.6);\n  if (rnd(1)) {\n    this.arpeggioFactor = rndr(1.037, 1.479);\n    this.arpeggioDelay = rndr(0.042, 0.114);\n  }\n  return this;\n};\n\nKnobs.prototype.laserShoot = function () {\n  this.shape = rnd(2);\n  if(this.shape === SINE && rnd(1))\n    this.shape = rnd(1);\n  if (rnd(2) === 0) {\n    this.frequency = rndr(321, 2861);\n    this.frequencyMin = frnd(38.8);\n    this.frequencySlide = rndr(-27.3, -174.5);\n  } else {\n    this.frequency = rndr(321, 3532);\n    this.frequencyMin = rndr(144, 2/3 * this.frequency);\n    this.frequencySlide = rndr(-2.15, -27.27);\n  }\n  if (this.shape === SAWTOOTH)\n    this.dutyCycle = 0;\n  if (rnd(1)) {\n    this.dutyCycle = rndr(1/4, 1/2);\n    this.dutyCycleSweep = rndr(0, -3.528);\n  } else {\n    this.dutyCycle = rndr(0.05, 0.3);\n    this.dutyCycleSweep = frnd(12.35);\n  }\n  this.attack = 0;\n  this.sustain = rndr(0.02, 0.2);\n  this.decay = frnd(0.36);\n  if (rnd(1))\n    this.punch = frnd(0.3);\n  if (rnd(2) === 0) {\n    this.flangerOffset = frnd(0.001);\n    this.flangerSweep = -frnd(0.04);\n  }\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n\n  return this;\n};\n\nKnobs.prototype.explosion = function () {\n  this.shape = NOISE;\n  if (rnd(1)) {\n    this.frequency = rndr(4, 224);\n    this.frequencySlide = rndr(-0.623, 17.2);\n  } else {\n    this.frequency = rndr(9, 2318);\n    this.frequencySlide = rndr(-5.1, -40.7);\n  }\n  if (rnd(4) === 0)\n    this.frequencySlide = 0;\n  if (rnd(2) === 0)\n    this.retriggerRate = rndr(4.5, 53);\n  this.attack = 0;\n  this.sustain = rndr(0.0227, 0.363);\n  this.decay = frnd(0.567);\n  if (rnd(1)) {\n    this.flangerOffset = rndr(-0.0021, 0.0083);\n    this.flangerSweep = -frnd(0.09);\n  }\n  this.punch = 0.2 + frnd(0.6);\n  if (rnd(1)) {\n    this.vibratoDepth = frnd(0.35);\n    this.vibratoRate = frnd(24.8);\n  }\n  if (rnd(2) === 0) {\n    this.arpeggioFactor = rndr(0.135, 2.358);\n    this.arpeggioDelay = rndr(0.00526, 0.0733);\n  }\n  return this;\n};\n\n\nKnobs.prototype.powerUp = function () {\n  if (rnd(1)) {\n    this.shape = SAWTOOTH;\n    this.dutyCycle = 0;\n  } else {\n    this.dutyCycle = rndr(0.2, 0.5);\n  }\n  this.frequency = rndr(145, 886);\n  if (rnd(1)) {\n    this.frequencySlide = rndr(0.636, 79.6);\n    this.retriggerRate = rndr(6, 53);\n  } else {\n    this.frequencySlide = rndr(0.0795, 9.94);\n    if (rnd(1)) {\n      this.vibratoDepth = frnd(0.35);\n      this.vibratoRate = frnd(24.8);\n    }\n  }\n  this.attack = 0;\n  this.sustain = frnd(0.363);\n  this.decay = rndr(0.023, 0.57);\n\n  return this;\n};\n\nKnobs.prototype.hitHurt = function () {\n  this.shape = rnd(2);\n  if (this.shape === SINE)\n    this.shape = NOISE;\n  if (this.shape === SQUARE)\n    this.dutyCycle = rndr(0.2, 0.5);\n  if (this.shape === SAWTOOTH)\n    this.dutyCycle = 0;\n  this.frequency = rndr(145, 2261);\n  this.frequencySlide = rndr(-17.2, -217.9);\n  this.attack = 0;\n  this.sustain = frnd(0.023);\n  this.decay = rndr(0.023, 0.2);\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n  return this;\n};\n\nKnobs.prototype.jump = function () {\n  this.shape = SQUARE;\n  this.dutyCycle = rndr(0.2, 0.5);\n  this.frequency = rndr(321, 1274);\n  this.frequencySlide = rndr(0.64, 17.2);\n  this.attack = 0;\n  this.sustain = rndr(0.023, 0.36);\n  this.decay = rndr(0.023, 0.2);\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n  if (rnd(1))\n    this.lowPassFrequency = rndr(2272, 44100);\n  return this;\n};\n\n\nKnobs.prototype.blipSelect = function () {\n  this.shape = rnd(1);\n  if (this.shape === SQUARE)\n    this.dutyCycle = rndr(0.2, 0.5);\n  else\n    this.dutyCycle = 0;\n  this.frequency = rndr(145, 1274);\n  this.attack = 0;\n  this.sustain = rndr(0.023, 0.09);\n  this.decay = frnd(0.09);\n  this.highPassFrequency = 353;\n  return this;\n};\n\nKnobs.prototype.random = function () {\n  if (rnd(1))\n    this.frequency = rndr(885.5, 7941.5);\n  else\n    this.frequency = rndr(3.5, 3532);\n  this.frequencySlide = rndr(-633, 639);\n  if (this.frequency > 1732 && this.frequencySlide > 5)\n    this.frequencySlide = -this.frequencySlide;\n  if (this.frequency < 145 && this.frequencySlide < -0.088)\n    this.frequencySlide = -this.frequencySlide;\n  this.frequencySlideSlide = rndr(-0.88, 0.88);\n  this.dutyCycle = frnd(1);\n  this.dudyCycleSweep = rndr(-17.64, 17.64);\n  this.vibratoDepth = rndr(-0.5, 0.5);\n  this.vibratoRate = rndr(0, 69);\n  this.attack = cube(frnd(1)) * 2.26;\n  this.sustain = sqr(frnd(1)) * 2.26 + 0.09;\n  this.decay = frnd(1) * 2.26;\n  this.punch = sqr(frnd(1)) * 0.64;\n  if (this.attack + this.sustain + this.decay < 0.45) {\n    this.sustain += rndr(0.5, 1.25);\n    this.decay += rndr(0.5, 1.25);\n  }\n  this.lowPassResonance = rndr(0.444, 0.97);\n  this.lowPassFrequency = frnd(39200);\n  this.lowPassSweep = rndr(0.012, 82);\n  if (this.lowPassFrequency < 35 && this.lowPassSweep < 0.802)\n    this.lowPassSweep = 1 - this.lowPassSweep;\n  this.highPassFrequency = 39200 * pow(frnd(1), 5);\n  this.highPassSweep = 555718 * pow(rndr(-1, 1), 5);\n  this.flangerOffset = 0.023 * cube(frnd(2) - 1);\n  this.flangerSweep = cube(frnd(2) - 1);\n  this.retriggerRate = frnd(1378);\n  this.arpeggioDelay = frnd(1.81);\n  this.arpeggioFactor = rndr(0.09, 10);\n  return this;\n};\n\nKnobs.prototype.tone = function () {\n  this.shape = SINE;\n  this.frequency = 440;\n  this.attack = 0;\n  this.sustain = 1;\n  this.decay = 0;\n  return this;\n};\n\nvar genners = 'pickupCoin,laserShoot,explosion,powerUp,hitHurt,jump,blipSelect,random,tone'.split(',');\nfor (var i = 0; i < genners.length; ++i) {\n  (function (g) {\n    if (!Knobs.prototype[g])\n      Knobs.prototype[g] = function () {\n        return this.translate(new Params()[g]());\n      }\n  })(genners[i]);\n}\n\n\nSoundEffect.prototype.init = function (ps) {\n  //\n  // Convert user-facing parameter values to units usable by the sound\n  // generator\n  //\n\n  this.initForRepeat = function() {\n    this.elapsedSinceRepeat = 0;\n\n    this.period = OVERSAMPLING * 44100 / ps.frequency;\n    this.periodMax = OVERSAMPLING * 44100 / ps.frequencyMin;\n    this.enableFrequencyCutoff = (ps.frequencyMin > 0);\n    this.periodMult = Math.pow(.5, ps.frequencySlide / 44100);\n    this.periodMultSlide = ps.frequencySlideSlide * Math.pow(2, -44101/44100)\n      / 44100;\n\n    this.dutyCycle = ps.dutyCycle;\n    this.dutyCycleSlide = ps.dutyCycleSweep / (OVERSAMPLING * 44100);\n\n    this.arpeggioMultiplier = 1 / ps.arpeggioFactor;\n    this.arpeggioTime = ps.arpeggioDelay * 44100;\n  }\n  this.initForRepeat();  // First time through, this is a bit of a misnomer\n\n  // Waveform shape\n  this.waveShape = ps.shape;\n\n  // Low pass filter\n  this.fltw = ps.lowPassFrequency / (OVERSAMPLING * 44100 + ps.lowPassFrequency);\n  this.enableLowPassFilter = ps.lowPassFrequency < 44100;\n  this.fltw_d = Math.pow(ps.lowPassSweep, 1/44100);\n  this.fltdmp = (1 - ps.lowPassResonance) * 9 * (.01 + this.fltw);\n\n  // High pass filter\n  this.flthp = ps.highPassFrequency / (OVERSAMPLING * 44100 + ps.highPassFrequency);\n  this.flthp_d = Math.pow(ps.highPassSweep, 1/44100);\n\n  // Vibrato\n  this.vibratoSpeed = ps.vibratoRate * 64 / 44100 / 10;\n  this.vibratoAmplitude = ps.vibratoDepth;\n\n  // Envelope\n  this.envelopeLength = [\n    Math.floor(ps.attack * 44100),\n    Math.floor(ps.sustain * 44100),\n    Math.floor(ps.decay * 44100)\n  ];\n  this.envelopePunch = ps.punch;\n\n  // Flanger\n  this.flangerOffset = ps.flangerOffset * 44100;\n  this.flangerOffsetSlide = ps.flangerSweep;\n\n  // Repeat\n  this.repeatTime = ps.retriggerRate ? 1 / (44100 * ps.retriggerRate) : 0;\n\n  // Gain\n  this.gain = Math.sqrt(Math.pow(10, ps.gain/10));\n\n  this.sampleRate = ps.sampleRate;\n  this.bitsPerChannel = ps.sampleSize;\n};\n\n\n// This is the function that converts a float to a uint8 or int16\n// cut from the bottom of `generate`\nfunction() {\n      if (this.bitsPerChannel === 8) {\n      // Rescale [-1, 1) to [0, 256)\n      sample = Math.floor((sample + 1) * 128);\n      if (sample > 255) {\n        sample = 255;\n        ++num_clipped;\n      } else if (sample < 0) {\n        sample = 0;\n        ++num_clipped;\n      }\n      buffer.push(sample);\n    } else {\n      // Rescale [-1, 1) to [-32768, 32768)\n      sample = Math.floor(sample * (1<<15));\n      if (sample >= (1<<15)) {\n        sample = (1 << 15)-1;\n        ++num_clipped;\n      } else if (sample < -(1<<15)) {\n        sample = -(1 << 15);\n        ++num_clipped;\n      }\n      buffer.push(sample & 0xFF);\n      buffer.push((sample >> 8) & 0xFF);\n    }\n}\n\n// Create a wav from a uint8 or int16\n// also cut from the bottom of `generate`\nfunction() {\n    var wave = new RIFFWAVE();\n    wave.header.sampleRate = this.sampleRate;\n    wave.header.bitsPerSample = this.bitsPerChannel;\n    wave.Make(buffer);\n    wave.clipping = num_clipped;\n    return wave;\n}",
      "mode": "100644",
      "type": "blob"
    },
    "main.coffee": {
      "path": "main.coffee",
      "content": "ApplicationTemplate = require \"./templates/application\"\n\nParams = require \"./params\"\nSoundEffect = require \"./sfx\"\n\nSerializer = require \"./serializer\"\n\nparams = new Params\n\naudioContext = new AudioContext\n\ncreateAndPlay = (type) ->\n  params = new Params\n  params[type]()\n\n  # Generate audio data\n  audioBuffer = SoundEffect(params, audioContext)\n\n  # Play buffer\n  node = new AudioBufferSourceNode audioContext,\n    buffer: audioBuffer\n  node.connect audioContext.destination\n  node.start()\n\n  dat = JSON.stringify(params)\n  console.log dat.length, dat\n\n  buf = Serializer.serialize(params)\n  console.log new Uint8Array(buf)\n\ndocument.body.appendChild ApplicationTemplate\n  coin: ->\n    createAndPlay(\"pickupCoin\")\n\n  laser: ->\n    createAndPlay(\"laserShoot\")\n\n  explosion: ->\n    createAndPlay(\"explosion\")\n\n  powerUp: ->\n    createAndPlay(\"powerUp\")\n\n  hit: ->\n    createAndPlay(\"hitHurt\")\n\n  jump: ->\n    createAndPlay(\"jump\")\n\n  blip: ->\n    createAndPlay(\"blipSelect\")\n\n  tone: ->\n    createAndPlay(\"tone\")\n",
      "mode": "100644",
      "type": "blob"
    },
    "templates/application.jadelet": {
      "path": "templates/application.jadelet",
      "content": "application\n  button(click=@coin) Coin\n  button(click=@laser) Laser\n  button(click=@explosion) Explosion\n  button(click=@powerUp) Power Up\n  button(click=@hit) Hit\n  button(click=@jump) Jump\n  button(click=@blip) Blip\n  button(click=@tone) Tone\n",
      "mode": "100644",
      "type": "blob"
    },
    "test/params.coffee": {
      "path": "test/params.coffee",
      "content": "{Params} = require \"../sfxr\"\n\ndescribe \"params\", ->\n  it \"should exist\", ->\n    params = new Params\n\n    assert params\n",
      "mode": "100644"
    },
    "sfx.js": {
      "path": "sfx.js",
      "content": "module.exports = function(ps, audioContext) {\n  //\n  // Convert user-facing parameter values to units usable by the sound\n  // generator\n  //\n  var m = Math;\n  var floor = m.floor,\n    pow = m.pow,\n    abs = m.abs,\n    random = m.random;\n\n  var SQUARE = 0,\n    SAWTOOTH = 1,\n    SINE = 2,\n    NOISE = 3,\n    OVERSAMPLING = 8,\n    sampleRate = 44100;\n  \n  var i,\n    elapsedSinceRepeat, \n    period,\n    periodMax,\n    enableFrequencyCutoff,\n    periodMult,\n    periodMultSlide,\n    dutyCycle,\n    dutyCycleSlide,\n    arpeggioMultiplier,\n    arpeggioTime;\n\n  function initForRepeat() {\n    elapsedSinceRepeat = 0;\n\n    period = 100 / (ps.p_base_freq * ps.p_base_freq + 0.001);\n    periodMax = 100 / (ps.p_freq_limit * ps.p_freq_limit + 0.001);\n    enableFrequencyCutoff = (ps.p_freq_limit > 0);\n    periodMult = 1 - pow(ps.p_freq_ramp, 3) * 0.01;\n    periodMultSlide = -pow(ps.p_freq_dramp, 3) * 0.000001;\n\n    dutyCycle = 0.5 - ps.p_duty * 0.5;\n    dutyCycleSlide = -ps.p_duty_ramp * 0.00005;\n\n    if (ps.p_arp_mod >= 0)\n      arpeggioMultiplier = 1 - pow(ps.p_arp_mod, 2) * 0.9;\n    else\n      arpeggioMultiplier = 1 + pow(ps.p_arp_mod, 2) * 10;\n    arpeggioTime = floor(pow(1 - ps.p_arp_speed, 2) * 20000 + 32);\n    if (ps.p_arp_speed === 1)\n      arpeggioTime = 0;\n  }\n\n  initForRepeat();\n\n  // Waveform shape\n  var waveShape = parseInt(ps.wave_type);\n\n  // Filter\n  var fltw = pow(ps.p_lpf_freq, 3) * 0.1;\n  var enableLowPassFilter = (ps.p_lpf_freq != 1);\n  var fltw_d = 1 + ps.p_lpf_ramp * 0.0001;\n  var fltdmp = 5 / (1 + pow(ps.p_lpf_resonance, 2) * 20) * (0.01 + fltw);\n  if (fltdmp > 0.8)\n    fltdmp=0.8;\n  var flthp = pow(ps.p_hpf_freq, 2) * 0.1;\n  var flthp_d = 1 + ps.p_hpf_ramp * 0.0003;\n\n  // Vibrato\n  var vibratoSpeed = pow(ps.p_vib_speed, 2) * 0.01;\n  var vibratoAmplitude = ps.p_vib_strength * 0.5;\n\n  // Envelope\n  var envelopeLength = [\n    floor(ps.p_env_attack * ps.p_env_attack * 100000),\n    floor(ps.p_env_sustain * ps.p_env_sustain * 100000),\n    floor(ps.p_env_decay * ps.p_env_decay * 100000)\n  ];\n  var envelopePunch = ps.p_env_punch;\n\n  // Flanger\n  var flangerOffset = pow(ps.p_pha_offset, 2) * 1020;\n  if (ps.p_pha_offset < 0) \n    flangerOffset = -flangerOffset;\n  var flangerOffsetSlide = pow(ps.p_pha_ramp, 2) * 1;\n  if (ps.p_pha_ramp < 0) \n    flangerOffsetSlide = -flangerOffsetSlide;\n\n  // Repeat\n  var repeatTime = floor(pow(1 - ps.p_repeat_speed, 2) * 20000 + 32);\n  if (ps.p_repeat_speed === 0)\n    repeatTime = 0;\n\n  var gain = pow(2, ps.sound_vol) - 1;\n\n  var fltp = 0;\n  var fltdp = 0;\n  var fltphp = 0;\n\n  // TODO: Deterministic output! Don't randomize noise buffer here\n  var noise_buffer = [];\n  for (i = 0; i < 32; ++i)\n    noise_buffer[i] = random() * 2 - 1;\n\n  var envelopeStage = 0;\n  var envelopeElapsed = 0;\n\n  var vibratoPhase = 0;\n\n  var phase = 0;\n  var ipp = 0;\n  var flanger_buffer = [];\n  for (i = 0; i < 1024; ++i)\n    flanger_buffer[i] = 0;\n\n  var num_clipped = 0;\n\n  var buffer = [];\n\n  for(var t = 0; ; ++t) {\n\n    // Repeats\n    if (repeatTime !== 0 && ++elapsedSinceRepeat >= repeatTime)\n      initForRepeat();\n\n    // Arpeggio (single)\n    if(arpeggioTime !== 0 && t >= arpeggioTime) {\n      arpeggioTime = 0;\n      period *= arpeggioMultiplier;\n    }\n\n    // Frequency slide, and frequency slide slide!\n    periodMult += periodMultSlide;\n    period *= periodMult;\n    if(period > periodMax) {\n      period = periodMax;\n      if (enableFrequencyCutoff)\n        break;\n    }\n\n    // Vibrato\n    var rfperiod = period;\n    if (vibratoAmplitude > 0) {\n      vibratoPhase += vibratoSpeed;\n      rfperiod = period * (1 + m.sin(vibratoPhase) * vibratoAmplitude);\n    }\n    var iperiod = floor(rfperiod);\n    if (iperiod < OVERSAMPLING) \n      iperiod = OVERSAMPLING;\n\n    // Square wave duty cycle\n    dutyCycle += dutyCycleSlide;\n    if (dutyCycle < 0) \n      dutyCycle = 0;\n    if (dutyCycle > 0.5) \n      dutyCycle = 0.5;\n\n    // Volume envelope\n    if (++envelopeElapsed > envelopeLength[envelopeStage]) {\n      envelopeElapsed = 0;\n      if (++envelopeStage > 2)\n        break;\n    }\n    var env_vol;\n    var envf = envelopeElapsed / envelopeLength[envelopeStage];\n    if (envelopeStage === 0) {         // Attack\n      env_vol = envf;\n    } else if (envelopeStage === 1) {  // Sustain\n      env_vol = 1 + (1 - envf) * 2 * envelopePunch;\n    } else {                           // Decay\n      env_vol = 1 - envf;\n    }\n\n    // Flanger step\n    flangerOffset += flangerOffsetSlide;\n    var iphase = abs(floor(flangerOffset));\n    if (iphase > 1023) \n      iphase = 1023;\n\n    if (flthp_d !== 0) {\n      flthp *= flthp_d;\n      if (flthp < 0.00001)\n        flthp = 0.00001;\n      if (flthp > 0.1)\n        flthp = 0.1;\n    }\n\n    // 8x oversampling\n    var sample = 0;\n    for (var si = 0; si < OVERSAMPLING; ++si) {\n      var sub_sample = 0;\n      phase++;\n      if (phase >= iperiod) {\n        phase %= iperiod;\n        if (waveShape === NOISE)\n          for(var i = 0; i < 32; ++i)\n            noise_buffer[i] = random() * 2 - 1;\n      }\n\n      // Base waveform\n      var fp = phase / iperiod;\n      if (waveShape === SQUARE) {\n        if (fp < dutyCycle)\n          sub_sample=0.5;\n        else\n          sub_sample=-0.5;\n      } else if (waveShape === SAWTOOTH) {\n        if (fp < dutyCycle)\n          sub_sample = -1 + 2 * fp/dutyCycle;\n        else\n          sub_sample = 1 - 2 * (fp-dutyCycle)/(1-dutyCycle);\n      } else if (waveShape === SINE) {\n        sub_sample = m.sin(fp * 2 * m.PI);\n      } else if (waveShape === NOISE) {\n        sub_sample = noise_buffer[floor(phase * 32 / iperiod)];\n      } else {\n        throw \"ERROR: Bad wave type: \" + waveShape;\n      }\n\n      // Low-pass filter\n      var pp = fltp;\n      fltw *= fltw_d;\n      if (fltw < 0)\n        fltw = 0;\n      if (fltw > 0.1)\n        fltw = 0.1;\n      if (enableLowPassFilter) {\n        fltdp += (sub_sample - fltp) * fltw;\n        fltdp -= fltdp * fltdmp;\n      } else {\n        fltp = sub_sample;\n        fltdp = 0;\n      }\n      fltp += fltdp;\n\n      // High-pass filter\n      fltphp += fltp - pp;\n      fltphp -= fltphp * flthp;\n      sub_sample = fltphp;\n\n      // Flanger\n      flanger_buffer[ipp & 1023] = sub_sample;\n      sub_sample += flanger_buffer[(ipp - iphase + 1024) & 1023];\n      ipp = (ipp + 1) & 1023;\n\n      // final accumulation and envelope application\n      sample += sub_sample * env_vol;\n    }\n\n    sample = sample / OVERSAMPLING;\n    sample *= gain;\n\n    buffer.push(sample);\n  }\n\n  var float32Array = new Float32Array(buffer);\n\n  // Create buffer\n  var audioBuffer = audioContext.createBuffer(1, float32Array.length, sampleRate);\n  var channelData = audioBuffer.getChannelData(0);\n  channelData.set(float32Array);\n\n  return audioBuffer;\n};\n",
      "mode": "100644"
    },
    "params.js": {
      "path": "params.js",
      "content": "var SQUARE = 0,\n  SAWTOOTH = 1,\n  SINE = 2,\n  NOISE = 3;\n\nfunction sqr(x) { return x * x }\nfunction cube(x) { return x * x * x }\nfunction sign(x) { return x < 0 ? -1 : 1 }\nfunction log(x, b) { return Math.log(x) / Math.log(b); }\nvar pow = Math.pow;\n\n// Sound generation parameters are on [0,1] unless noted SIGNED & thus\n// on [-1,1]\nfunction Params() {\n  // Wave shape\n  this.wave_type = SQUARE;\n\n  // Envelope\n  this.p_env_attack = 0;   // Attack time\n  this.p_env_sustain = 0.3;  // Sustain time\n  this.p_env_punch = 0;    // Sustain punch\n  this.p_env_decay = 0.4;    // Decay time\n\n  // Tone\n  this.p_base_freq = 0.3;    // Start frequency\n  this.p_freq_limit = 0;   // Min frequency cutoff\n  this.p_freq_ramp = 0;    // Slide (SIGNED)\n  this.p_freq_dramp = 0;   // Delta slide (SIGNED)\n  // Vibrato\n  this.p_vib_strength = 0; // Vibrato depth\n  this.p_vib_speed = 0;    // Vibrato speed\n\n  // Tonal change\n  this.p_arp_mod = 0;      // Change amount (SIGNED)\n  this.p_arp_speed = 0;    // Change speed\n\n  // Square wave duty (proportion of time signal is high vs. low)\n  this.p_duty = 0;         // Square duty\n  this.p_duty_ramp = 0;    // Duty sweep (SIGNED)\n\n  // Repeat\n  this.p_repeat_speed = 0; // Repeat speed\n\n  // Flanger\n  this.p_pha_offset = 0;   // Flanger offset (SIGNED)\n  this.p_pha_ramp = 0;     // Flanger sweep (SIGNED)\n\n  // Low-pass filter\n  this.p_lpf_freq = 1;     // Low-pass filter cutoff\n  this.p_lpf_ramp = 0;     // Low-pass filter cutoff sweep (SIGNED)\n  this.p_lpf_resonance = 0;// Low-pass filter resonance\n  // High-pass filter\n  this.p_hpf_freq = 0;     // High-pass filter cutoff\n  this.p_hpf_ramp = 0;     // High-pass filter cutoff sweep (SIGNED)\n\n  // Sample parameters\n  this.sound_vol = 0.5;\n}\n\n\nfunction frnd(range) {\n  return Math.random() * range;\n}\n\nfunction rndr(from, to) {\n  return Math.random() * (to - from) + from;\n}\n\nfunction rnd(max) {\n  return Math.floor(Math.random() * (max + 1));\n}\n\n\n// These functions roll up random sounds appropriate to various\n// typical game events:\n\n\nParams.prototype.pickupCoin = function () {\n  this.p_base_freq = 0.4 + frnd(0.5);\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.1);\n  this.p_env_decay = 0.1 + frnd(0.4);\n  this.p_env_punch = 0.3 + frnd(0.3);\n  if (rnd(1)) {\n    this.p_arp_speed = 0.5 + frnd(0.2);\n    this.p_arp_mod = 0.2 + frnd(0.4);\n  }\n  return this;\n};\n\n\nParams.prototype.laserShoot = function () {\n  this.wave_type = rnd(2);\n  if(this.wave_type === SINE && rnd(1))\n    this.wave_type = rnd(1);\n  if (rnd(2) === 0) {\n    this.p_base_freq = 0.3 + frnd(0.6);\n    this.p_freq_limit = frnd(0.1);\n    this.p_freq_ramp = -0.35 - frnd(0.3);\n  } else {\n    this.p_base_freq = 0.5 + frnd(0.5);\n    this.p_freq_limit = this.p_base_freq - 0.2 - frnd(0.6);\n    if (this.p_freq_limit < 0.2) this.p_freq_limit = 0.2;\n    this.p_freq_ramp = -0.15 - frnd(0.2);\n  }\n  if (this.wave_type === SAWTOOTH)\n    this.p_duty = 1;\n  if (rnd(1)) {\n    this.p_duty = frnd(0.5);\n    this.p_duty_ramp = frnd(0.2);\n  } else {\n    this.p_duty = 0.4 + frnd(0.5);\n    this.p_duty_ramp = -frnd(0.7);\n  }\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.2);\n  this.p_env_decay = frnd(0.4);\n  if (rnd(1))\n    this.p_env_punch = frnd(0.3);\n  if (rnd(2) === 0) {\n    this.p_pha_offset = frnd(0.2);\n    this.p_pha_ramp = -frnd(0.2);\n  }\n  //if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n\n  return this;\n};\n\n\nParams.prototype.explosion = function () {\n  this.wave_type = NOISE;\n  if (rnd(1)) {\n    this.p_base_freq = sqr(0.1 + frnd(0.4));\n    this.p_freq_ramp = -0.1 + frnd(0.4);\n  } else {\n    this.p_base_freq = sqr(0.2 + frnd(0.7));\n    this.p_freq_ramp = -0.2 - frnd(0.2);\n  }\n  if (rnd(4) === 0)\n    this.p_freq_ramp = 0;\n  if (rnd(2) === 0)\n    this.p_repeat_speed = 0.3 + frnd(0.5);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.3);\n  this.p_env_decay = frnd(0.5);\n  if (rnd(1)) {\n    this.p_pha_offset = -0.3 + frnd(0.9);\n    this.p_pha_ramp = -frnd(0.3);\n  }\n  this.p_env_punch = 0.2 + frnd(0.6);\n  if (rnd(1)) {\n    this.p_vib_strength = frnd(0.7);\n    this.p_vib_speed = frnd(0.6);\n  }\n  if (rnd(2) === 0) {\n    this.p_arp_speed = 0.6 + frnd(0.3);\n    this.p_arp_mod = 0.8 - frnd(1.6);\n  }\n\n  return this;\n};\n\n\nParams.prototype.powerUp = function () {\n  if (rnd(1)) {\n    this.wave_type = SAWTOOTH;\n    this.p_duty = 1;\n  } else {\n    this.p_duty = frnd(0.6);\n  }\n  this.p_base_freq = 0.2 + frnd(0.3);\n  if (rnd(1)) {\n    this.p_freq_ramp = 0.1 + frnd(0.4);\n    this.p_repeat_speed = 0.4 + frnd(0.4);\n  } else {\n    this.p_freq_ramp = 0.05 + frnd(0.2);\n    if (rnd(1)) {\n      this.p_vib_strength = frnd(0.7);\n      this.p_vib_speed = frnd(0.6);\n    }\n  }\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.4);\n  this.p_env_decay = 0.1 + frnd(0.4);\n\n  return this;\n};\n\n\nParams.prototype.hitHurt = function () {\n  this.wave_type = rnd(2);\n  if (this.wave_type === SINE)\n    this.wave_type = NOISE;\n  if (this.wave_type === SQUARE)\n    this.p_duty = frnd(0.6);\n  if (this.wave_type === SAWTOOTH)\n    this.p_duty = 1;\n  this.p_base_freq = 0.2 + frnd(0.6);\n  this.p_freq_ramp = -0.3 - frnd(0.4);\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.1);\n  this.p_env_decay = 0.1 + frnd(0.2);\n  if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n  return this;\n};\n\n\nParams.prototype.jump = function () {\n  this.wave_type = SQUARE;\n  this.p_duty = frnd(0.6);\n  this.p_base_freq = 0.3 + frnd(0.3);\n  this.p_freq_ramp = 0.1 + frnd(0.2);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.3);\n  this.p_env_decay = 0.1 + frnd(0.2);\n  if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n  if (rnd(1))\n    this.p_lpf_freq = 1 - frnd(0.6);\n  return this;\n};\n\n\nParams.prototype.blipSelect = function () {\n  this.wave_type = rnd(1);\n  if (this.wave_type === SQUARE)\n    this.p_duty = frnd(0.6);\n  else\n    this.p_duty = 1;\n  this.p_base_freq = 0.2 + frnd(0.4);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.1);\n  this.p_env_decay = frnd(0.2);\n  this.p_hpf_freq = 0.1;\n  return this;\n};\n\n\nParams.prototype.tone = function () {\n  this.wave_type = SINE;\n  this.p_base_freq = 0.35173364; // 440 Hz\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.6641; // 1 sec\n  this.p_env_decay = 0;\n  this.p_env_punch = 0;\n  return this;\n};\n\n\nParams.prototype.mutate = function () {\n  if (rnd(1)) this.p_base_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_freq_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_freq_dramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_duty += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_duty_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_strength += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_delay += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_attack += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_sustain += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_decay += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_punch += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_resonance += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_hpf_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_hpf_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_pha_offset += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_pha_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_repeat_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_arp_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_arp_mod += frnd(0.1) - 0.05;\n};\n\n\nParams.prototype.random = function () {\n  if (rnd(1))\n    this.p_base_freq = cube(frnd(2) - 1) + 0.5;\n  else\n    this.p_base_freq = sqr(frnd(1));\n  this.p_freq_limit = 0;\n  this.p_freq_ramp = Math.pow(frnd(2) - 1, 5);\n  if (this.p_base_freq > 0.7 && this.p_freq_ramp > 0.2)\n    this.p_freq_ramp = -this.p_freq_ramp;\n  if (this.p_base_freq < 0.2 && this.p_freq_ramp < -0.05)\n    this.p_freq_ramp = -this.p_freq_ramp;\n  this.p_freq_dramp = Math.pow(frnd(2) - 1, 3);\n  this.p_duty = frnd(2) - 1;\n  this.p_duty_ramp = Math.pow(frnd(2) - 1, 3);\n  this.p_vib_strength = Math.pow(frnd(2) - 1, 3);\n  this.p_vib_speed = rndr(-1, 1);\n  this.p_env_attack = cube(rndr(-1, 1));\n  this.p_env_sustain = sqr(rndr(-1, 1));\n  this.p_env_decay = rndr(-1, 1);\n  this.p_env_punch = Math.pow(frnd(0.8), 2);\n  if (this.p_env_attack + this.p_env_sustain + this.p_env_decay < 0.2) {\n    this.p_env_sustain += 0.2 + frnd(0.3);\n    this.p_env_decay += 0.2 + frnd(0.3);\n  }\n  this.p_lpf_resonance = rndr(-1, 1);\n  this.p_lpf_freq = 1 - Math.pow(frnd(1), 3);\n  this.p_lpf_ramp = Math.pow(frnd(2) - 1, 3);\n  if (this.p_lpf_freq < 0.1 && this.p_lpf_ramp < -0.05)\n    this.p_lpf_ramp = -this.p_lpf_ramp;\n  this.p_hpf_freq = Math.pow(frnd(1), 5);\n  this.p_hpf_ramp = Math.pow(frnd(2) - 1, 5);\n  this.p_pha_offset = Math.pow(frnd(2) - 1, 3);\n  this.p_pha_ramp = Math.pow(frnd(2) - 1, 3);\n  this.p_repeat_speed = frnd(2) - 1;\n  this.p_arp_speed = frnd(2) - 1;\n  this.p_arp_mod = frnd(2) - 1;\n  return this;\n};\n\nmodule.exports = Params;\n",
      "mode": "100644"
    },
    "lib/riffwave.js": {
      "path": "lib/riffwave.js",
      "content": "/*\n * RIFFWAVE.js v0.03 - Audio encoder for HTML5 <audio> elements.\n * Copyright (C) 2011 Pedro Ladaria <pedro.ladaria at Gmail dot com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * version 2 as published by the Free Software Foundation.\n * The full license is available at http://www.gnu.org/licenses/gpl.html\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n *\n * Changelog:\n *\n * 0.01 - First release\n * 0.02 - New faster base64 encoding\n * 0.03 - Blob URLs\n *\n */\n\nvar RIFFWAVE = function(data) {\n\n  this.data = [];        // Byte array containing audio samples\n  this.wav = [];         // Array containing the generated wave file\n  this.dataURI = '';     // http://en.wikipedia.org/wiki/Data_URI_scheme\n\n  this.header = {                         // OFFS SIZE NOTES\n    chunkId      : [0x52,0x49,0x46,0x46], // 0    4    \"RIFF\" = 0x52494646\n    chunkSize    : 0,                     // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)\n    format       : [0x57,0x41,0x56,0x45], // 8    4    \"WAVE\" = 0x57415645\n    subChunk1Id  : [0x66,0x6d,0x74,0x20], // 12   4    \"fmt \" = 0x666d7420\n    subChunk1Size: 16,                    // 16   4    16 for PCM\n    audioFormat  : 1,                     // 20   2    PCM = 1\n    numChannels  : 1,                     // 22   2    Mono = 1, Stereo = 2, etc.\n    sampleRate   : 8000,                  // 24   4    8000, 44100, etc\n    byteRate     : 0,                     // 28   4    SampleRate*NumChannels*BitsPerSample/8\n    blockAlign   : 0,                     // 32   2    NumChannels*BitsPerSample/8\n    bitsPerSample: 8,                     // 34   2    8 bits = 8, 16 bits = 16, etc...\n    subChunk2Id  : [0x64,0x61,0x74,0x61], // 36   4    \"data\" = 0x64617461\n    subChunk2Size: 0                      // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8\n  };\n\n  function u32ToArray(i) { return [i&0xFF, (i>>8)&0xFF, (i>>16)&0xFF, (i>>24)&0xFF]; }\n\n  function u16ToArray(i) { return [i&0xFF, (i>>8)&0xFF]; }\n\n  this.Make = function(data) {\n    if (data instanceof Array) this.data = data;\n    this.header.byteRate = (this.header.sampleRate * this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.blockAlign = (this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.subChunk2Size = this.data.length;\n    this.header.chunkSize = 36 + this.header.subChunk2Size;\n\n    this.wav = this.header.chunkId.concat(\n      u32ToArray(this.header.chunkSize),\n      this.header.format,\n      this.header.subChunk1Id,\n      u32ToArray(this.header.subChunk1Size),\n      u16ToArray(this.header.audioFormat),\n      u16ToArray(this.header.numChannels),\n      u32ToArray(this.header.sampleRate),\n      u32ToArray(this.header.byteRate),\n      u16ToArray(this.header.blockAlign),\n      u16ToArray(this.header.bitsPerSample),\n      this.header.subChunk2Id,\n      u32ToArray(this.header.subChunk2Size),\n      this.data\n    );\n\n    var dat = Uint8Array.from(this.wav);\n    var blob = new Blob([dat], {type: \"audio/wav\"});\n    var url = URL.createObjectURL(blob);\n    this.dataURI = url;\n  };\n\n  if (data instanceof Array) this.Make(data);\n\n}; // end RIFFWAVE\n\n\nif (typeof exports != 'undefined')  // For node.js\n  exports.RIFFWAVE = RIFFWAVE;\n",
      "mode": "100644"
    },
    "serializer.coffee": {
      "path": "serializer.coffee",
      "content": "module.exports =\n  serialize: (params) ->\n    buffer = new ArrayBuffer(100)\n\n    dataView = new DataView(buffer)\n\n    Object.keys(params).forEach (key, i) ->\n      param = params[key]\n      if i is 0\n        # 4 byte sfxz header\n        \"fxz\".split(\"\").forEach (s, n) ->\n          dataView.setUint8(n, s.charCodeAt(0))\n        # version\n        dataView.setUint8(3, 1)\n        # byte 4 wave_type\n        dataView.setUint8(4, param)\n        # bytes 5, 6, 7 unused for now\n      else\n        # Little endian float32s for the other 23 fields\n        dataView.setFloat32((i + 1) * 4, param, true)\n\n    return buffer\n\n  deserialize: (arrayBuffer, params) ->\n    buffer = new ArrayBuffer(100)\n\n    dataView = new DataView(buffer)\n\n    Object.keys(params).forEach (key, i) ->\n      if i is 0\n        # 4 byte sfxz header\n        \"fxz\".split(\"\").forEach (s, n) ->\n          charCode = s.charCodeAt(0)\n          if charCode != dataView.getUint8(n)\n            throw new Error \"Unknown file format: expected '#{s}' (#{charCode}) at byte #{n}\"\n        # version\n        version = dataView.getUint8(3)\n        if version != 1\n          throw new Error \"Unknown version '#{version}': expected 1\"\n        # byte 4 wave_type\n        params[key] = dataView.getUint8(4)\n        # bytes 5, 6, 7 unused for now\n      else\n        # Little endian float32s for the other 23 fields\n        params[key] = dataView.getFloat32((i + 1) * 4, true)\n\n    return params\n",
      "mode": "100644"
    }
  },
  "distribution": {
    "demo": {
      "path": "demo",
      "content": "\nvar PARAMS;\nvar SOUND;\nvar SOUND_VOL = 0.25;\nvar SAMPLE_RATE = 44100;\nvar SAMPLE_SIZE = 8;\n\nParams.prototype.query = function () {\n  var result = \"\";\n  var that = this;\n  $.each(this, function (key,value) {\n    if (that.hasOwnProperty(key))\n      result += \"&\" + key + \"=\" + value;\n  });\n  return result.substring(1);\n};\n\nfunction gen(fx) {\n  PARAMS = new Params();\n  PARAMS.sound_vol = SOUND_VOL;\n  PARAMS.sample_rate = SAMPLE_RATE;\n  PARAMS.sample_size = SAMPLE_SIZE;\n  PARAMS[fx]();\n  $(\"#wav\").text(fx + \".wav\");\n  updateUi();\n  play();\n}\n\nfunction mut() {\n  PARAMS.mutate();\n  updateUi();\n  play();\n}\n\nfunction play(noregen) {\n  setTimeout(function () {\n    var audio = new Audio();\n    if (!noregen) {\n      SOUND = new SoundEffect(PARAMS).generate();\n      $(\"#file_size\").text(Math.round(SOUND.wav.length / 1024) + \"kB\");\n      $(\"#num_samples\").text(SOUND.header.subChunk2Size /\n                             (SOUND.header.bitsPerSample >> 3));\n      $(\"#clipping\").text(SOUND.clipping);\n    }\n    audio.src = SOUND.dataURI;\n    $(\"#wav\").attr(\"href\", SOUND.dataURI);\n    $(\"#sfx\").attr(\"href\", \"sfx.wav?\" + PARAMS.query());\n    audio.play();\n  }, 0);\n}\n\nfunction disenable() {\n  var duty = PARAMS.wave_type == SQUARE || PARAMS.wave_type == SAWTOOTH;\n  $(\"#p_duty\").slider(\"option\", \"disabled\", !duty);\n  $(\"#p_duty_ramp\").slider(\"option\", \"disabled\", !duty);\n}\n\nfunction updateUi() {\n  $.each(PARAMS, function (param, value) {\n    if (param == \"wave_type\") {\n      $(\"#shape input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else if (param == \"sample_rate\") {\n      $(\"#hz input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else if (param == \"sample_size\") {\n      $(\"#bits input:radio[value=\" + value + \"]\").\n        prop('checked', true).button(\"refresh\");\n    } else {\n      var id = \"#\" + param;\n      $(id).slider(\"value\", 1000 * value);\n      $(id).each(function(){convert(this, PARAMS[this.id]);});\n    }\n  });\n  disenable();\n}\n\n\n$(function() {\n  $(\"#shape\").buttonset();\n  $(\"#hz\").buttonset();\n  $(\"#bits\").buttonset();\n  $(\"#shape input:radio\").change(function (event) {\n    PARAMS.wave_type = parseInt(event.target.value);\n    disenable();\n    play();\n  });\n  $(\"#hz input:radio\").change(function (event) {\n    SAMPLE_RATE = PARAMS.sample_rate = parseInt(event.target.value);\n    play();\n  });\n  $(\"#bits input:radio\").change(function (event) {\n    SAMPLE_SIZE = PARAMS.sample_size = parseInt(event.target.value);\n    play();\n  });\n  $(\"button\").button();\n  $(\".slider\").slider({\n    value: 1000,\n    min: 0,\n    max: 1000,\n    slide: function (event, ui) {\n      convert(event.target, ui.value / 1000.0);\n    },\n    change: function(event, ui) {\n      if (event.originalEvent) {\n        PARAMS[event.target.id] = ui.value / 1000.0;\n        convert(event.target, PARAMS[event.target.id]);\n        play();\n      }\n    }\n  });\n  $(\".slider\").filter(\".signed\").\n    slider(\"option\", \"min\", -1000).\n    slider(\"value\", 0);\n  $('.slider').each(function () {\n      var is = this.id;\n      if (!$('label[for=\"' + is + '\"]').length)\n        $(this).parent().parent().find('th').append($('<label>',\n                                                      {for: is}));\n    });\n\n  var UNITS = {\n    p_env_attack:  function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n    p_env_sustain: function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n    p_env_punch:   function (v) { return '+' + (v * 100).toPrecision(4) + '%'},\n    p_env_decay:   function (v) { return (v / 44100).toPrecision(4) + ' sec' },\n\n    p_base_freq:  'Hz',\n    p_freq_limit: 'Hz',\n    p_freq_ramp:  function (v) {\n      return (44100*Math.log(v)/Math.log(0.5)).toPrecision(4) + ' 8va/sec'; },\n    p_freq_dramp: function (v) {\n      return (v*44100 / Math.pow(2, -44101/44100)).toPrecision(4) +\n        ' 8va/sec^2?'; },\n\n    p_vib_speed:    function (v) { return v === 0 ? 'OFF' :\n                                   (441000/64 * v).toPrecision(4) + ' Hz'},\n    p_vib_strength: function (v) { return v === 0 ? 'OFF' :\n                                   '&plusmn; ' + (v*100).toPrecision(4) + '%' },\n\n    p_arp_mod:   function (v) { return ((v === 1) ? 'OFF' :\n                                        'x ' + (1/v).toPrecision(4)) },\n    p_arp_speed: function (v) { return (v === 0 ? 'OFF' :\n                                        (v / 44100).toPrecision(4) +' sec') },\n\n    p_duty:      function (v) { return (100 * v).toPrecision(4) + '%'; },\n    p_duty_ramp: function (v) { return (8 * 44100 * v).toPrecision(4) +'%/sec'},\n\n    p_repeat_speed: function (v) { return v === 0 ? 'OFF' :\n                                   (44100/v).toPrecision(4) + ' Hz' },\n\n    p_pha_offset: function (v) { return v === 0 ? 'OFF' :\n                                 (1000*v/44100).toPrecision(4) + ' msec' },\n    // Not so sure about this:\n    p_pha_ramp:   function (v) { return v === 0 ? 'OFF' :\n                 (1000*v).toPrecision(4) + ' msec/sec' },\n\n    p_lpf_freq:   function (v) {\n      return (v === 0.1) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },\n    p_lpf_ramp:  function (v) {  if (v === 1) return 'OFF';\n      return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },\n    p_lpf_resonance: function (v) { return (100*(1-v*0.11)).toPrecision(4)+'%';},\n\n    p_hpf_freq:   function (v) {\n      return (v === 0) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },\n    p_hpf_ramp: function (v) {  if (v === 1) return 'OFF';\n      return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },\n\n    sound_vol: function (v) {\n      v = 10 * Math.log(v*v) / Math.log(10);\n      var sign = v >= 0 ? '+' : '';\n      return sign + v.toPrecision(4) + ' dB';\n    }\n  };\n\n  var CONVERSIONS = {\n    p_env_attack:  function (v) { return v * v * 100000.0 },\n    p_env_sustain: function (v) { return v * v * 100000.0 },\n    p_env_punch:   function (v) { return v },\n    p_env_decay:   function (v) { return v * v * 100000.0 },\n\n    p_base_freq:  function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },\n    p_freq_limit: function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },\n    p_freq_ramp:  function (v) { return 1.0 - Math.pow(v, 3.0) * 0.01 },\n    p_freq_dramp: function (v) { return -Math.pow(v, 3.0) * 0.000001 },\n\n    p_vib_speed:    function (v) { return Math.pow(v, 2.0) * 0.01 },\n    p_vib_strength: function (v) { return v * 0.5 },\n\n    p_arp_mod:   function (v) {\n      return v >= 0 ? 1.0 - Math.pow(v, 2) * 0.9 : 1.0 + Math.pow(v, 2) * 10; },\n    p_arp_speed: function (v) { return (v === 1.0) ? 0 :\n                                Math.floor(Math.pow(1.0 - v, 2.0) * 20000 +32)},\n\n    p_duty:      function (v) { return 0.5 - v * 0.5; },\n    p_duty_ramp: function (v) { return -v * 0.00005 },\n\n    p_repeat_speed: function (v) { return (v === 0) ? 0 :\n                                   Math.floor(Math.pow(1-v, 2) * 20000) + 32 },\n\n    p_pha_offset: function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2)*1020 },\n    p_pha_ramp:   function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2) },\n\n    p_lpf_freq:   function (v) { return Math.pow(v, 3) * 0.1 },\n    p_lpf_ramp:   function (v) { return 1.0 + v * 0.0001 },\n    p_lpf_resonance: function (v) { return 5.0 / (1.0 + Math.pow(v, 2) * 20) }, // * (0.01 + fltw);\n\n    p_hpf_freq: function (v) { return Math.pow(v, 2) * 0.1 },\n    p_hpf_ramp: function (v) { return 1.0 + v * 0.0003 },\n\n    sound_vol: function (v) { return Math.exp(v) - 1; }\n  };\n  for (var p in CONVERSIONS) {\n    var control = $('#' + p)[0];\n    control.convert = CONVERSIONS[p];\n    control.units = UNITS[p];\n  }\n\n  gen(\"pickupCoin\");\n});\n\nfunction convert(control, v) {\n  if (control.convert) {\n    v = control.convert(v);\n    control.convertedValue = v;\n    if (typeof control.units === 'function')\n      v = control.units(v);\n    else\n      v = v.toPrecision(4) + ' ' + control.units;\n    $('label[for=\"' + control.id + '\"]').html(v);\n  }\n}\n",
      "type": "blob"
    },
    "knobs": {
      "path": "knobs",
      "content": "// Dumping this duplicat stuff in here for now\n\nvar defaultKnobs = {\n  shape: SQUARE, // SQUARE/SAWTOOTH/SINE/NOISE\n\n  attack:  0,   // sec\n  sustain: 0.2, // sec\n  punch:   0,   // proportion\n  decay:   0.2, // sec\n\n  frequency:        1000, // Hz\n  frequencyMin:        0, // Hz\n  frequencySlide:      0, // 8va/sec\n  frequencySlideSlide: 0, // 8va/sec/sec\n\n  vibratoDepth:  0, // proportion\n  vibratoRate:  10, // Hz\n\n  arpeggioFactor: 1,   // multiple of frequency\n  arpeggioDelay:  0.1, // sec\n\n  dutyCycle:      0.5, // proportion of wavelength\n  dutyCycleSweep: 0,   // proportion/second\n\n  retriggerRate: 0, // Hz\n\n  flangerOffset: 0, // sec\n  flangerSweep:  0, // offset/sec\n\n  lowPassFrequency: 44100, // Hz\n  lowPassSweep:     1,     // ^sec\n  lowPassResonance: 0.5,   // proportion\n\n  highPassFrequency: 0, // Hz\n  highPassSweep:     0, // ^sec\n\n  gain: -10, // dB\n\n  sampleRate: 44100, // Hz\n  sampleSize: 8,     // bits per channel\n};\n\n\nfunction Knobs(settings) {\n  settings = settings||{};\n  for (var i in defaultKnobs) {\n    if (settings.hasOwnProperty(i))\n      this[i] = settings[i];\n    else\n      this[i] = defaultKnobs[i];\n  }\n}\n\n// Translate from UI-friendly settings to human-friendly ones\nKnobs.prototype.translate = function (ps) {\n  this.shape = ps.wave_type;\n\n  this.attack = sqr(ps.p_env_attack) * 100000 / 44100;\n  this.sustain = sqr(ps.p_env_sustain) * 100000 / 44100;\n  this.punch = ps.p_env_punch;\n  this.decay = sqr(ps.p_env_decay) * 100000 / 44100;\n\n  this.frequency = OVERSAMPLING * 441 * (sqr(ps.p_base_freq) + 0.001);\n  if (ps.p_freq_limit > 0)\n    this.frequencyMin = OVERSAMPLING * 441 * (sqr(ps.p_freq_limit) + 0.001);\n  else\n    this.frequencyMin = 0;\n  this.enableFrequencyCutoff = (ps.p_freq_limit > 0);\n  this.frequencySlide = 44100 * log(1 - cube(ps.p_freq_ramp) / 100, 0.5);\n  this.frequencySlideSlide = -cube(ps.p_freq_dramp) / 1000000 *\n    44100 * pow(2, 44101/44100);\n\n  this.vibratoRate = 44100 * 10 / 64 * sqr(ps.p_vib_speed) / 100;\n  this.vibratoDepth = ps.p_vib_strength / 2;\n\n  this.arpeggioFactor = 1 / ((ps.p_arp_mod >= 0) ?\n                             1 - sqr(ps.p_arp_mod) * 0.9 :\n                             1 + sqr(ps.p_arp_mod) * 10);\n  this.arpeggioDelay = ((ps.p_arp_speed === 1) ? 0 :\n                Math.floor(sqr(1 - ps.p_arp_speed) * 20000 + 32) / 44100);\n\n  this.dutyCycle = (1 - ps.p_duty) / 2;\n  this.dutyCycleSweep = OVERSAMPLING * 44100 * -ps.p_duty_ramp / 20000;\n\n  this.retriggerRate = 44100 / ((ps.p_repeat_speed === 0) ? 0 :\n                       Math.floor(sqr(1 - ps.p_repeat_speed) * 20000) + 32);\n\n  this.flangerOffset = sign(ps.p_pha_offset) *\n    sqr(ps.p_pha_offset) * 1020 / 44100;\n  this.flangerSweep = sign(ps.p_pha_ramp) * sqr(ps.p_pha_ramp);\n\n  this.enableLowPassFilter = (ps.p_lpf_freq != 1);\n  function flurp(x) { return x / (1-x) }\n  this.lowPassFrequency = ps.p_lpf_freq === 1 ? 44100 :\n    Math.round(OVERSAMPLING * 44100 * flurp(cube(ps.p_lpf_freq) / 10));\n  this.lowPassSweep = pow(1 + ps.p_lpf_ramp / 10000, 44100);\n  this.lowPassResonance = 1 - (5 / (1 + sqr(ps.p_lpf_resonance) * 20)) / 9;\n\n  this.highPassFrequency = Math.round(OVERSAMPLING * 44100 *\n                                      flurp(sqr(ps.p_hpf_freq) / 10));\n  this.highPassSweep = pow(1 + ps.p_hpf_ramp * 0.0003, 44100);\n\n  this.gain = 10 * log(sqr(Math.exp(ps.sound_vol) - 1), 10);\n\n  this.sampleRate = ps.sample_rate;\n  this.sampleSize = ps.sample_size;\n\n  return this;\n};\n\nKnobs.prototype.pickupCoin = function () {\n  this.frequency = rndr(568, 2861);\n  this.attack = 0;\n  this.sustain = frnd(0.227);\n  this.decay = rndr(0.227, 0.567);\n  this.punch = rndr(0.3, 0.6);\n  if (rnd(1)) {\n    this.arpeggioFactor = rndr(1.037, 1.479);\n    this.arpeggioDelay = rndr(0.042, 0.114);\n  }\n  return this;\n};\n\nKnobs.prototype.laserShoot = function () {\n  this.shape = rnd(2);\n  if(this.shape === SINE && rnd(1))\n    this.shape = rnd(1);\n  if (rnd(2) === 0) {\n    this.frequency = rndr(321, 2861);\n    this.frequencyMin = frnd(38.8);\n    this.frequencySlide = rndr(-27.3, -174.5);\n  } else {\n    this.frequency = rndr(321, 3532);\n    this.frequencyMin = rndr(144, 2/3 * this.frequency);\n    this.frequencySlide = rndr(-2.15, -27.27);\n  }\n  if (this.shape === SAWTOOTH)\n    this.dutyCycle = 0;\n  if (rnd(1)) {\n    this.dutyCycle = rndr(1/4, 1/2);\n    this.dutyCycleSweep = rndr(0, -3.528);\n  } else {\n    this.dutyCycle = rndr(0.05, 0.3);\n    this.dutyCycleSweep = frnd(12.35);\n  }\n  this.attack = 0;\n  this.sustain = rndr(0.02, 0.2);\n  this.decay = frnd(0.36);\n  if (rnd(1))\n    this.punch = frnd(0.3);\n  if (rnd(2) === 0) {\n    this.flangerOffset = frnd(0.001);\n    this.flangerSweep = -frnd(0.04);\n  }\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n\n  return this;\n};\n\nKnobs.prototype.explosion = function () {\n  this.shape = NOISE;\n  if (rnd(1)) {\n    this.frequency = rndr(4, 224);\n    this.frequencySlide = rndr(-0.623, 17.2);\n  } else {\n    this.frequency = rndr(9, 2318);\n    this.frequencySlide = rndr(-5.1, -40.7);\n  }\n  if (rnd(4) === 0)\n    this.frequencySlide = 0;\n  if (rnd(2) === 0)\n    this.retriggerRate = rndr(4.5, 53);\n  this.attack = 0;\n  this.sustain = rndr(0.0227, 0.363);\n  this.decay = frnd(0.567);\n  if (rnd(1)) {\n    this.flangerOffset = rndr(-0.0021, 0.0083);\n    this.flangerSweep = -frnd(0.09);\n  }\n  this.punch = 0.2 + frnd(0.6);\n  if (rnd(1)) {\n    this.vibratoDepth = frnd(0.35);\n    this.vibratoRate = frnd(24.8);\n  }\n  if (rnd(2) === 0) {\n    this.arpeggioFactor = rndr(0.135, 2.358);\n    this.arpeggioDelay = rndr(0.00526, 0.0733);\n  }\n  return this;\n};\n\n\nKnobs.prototype.powerUp = function () {\n  if (rnd(1)) {\n    this.shape = SAWTOOTH;\n    this.dutyCycle = 0;\n  } else {\n    this.dutyCycle = rndr(0.2, 0.5);\n  }\n  this.frequency = rndr(145, 886);\n  if (rnd(1)) {\n    this.frequencySlide = rndr(0.636, 79.6);\n    this.retriggerRate = rndr(6, 53);\n  } else {\n    this.frequencySlide = rndr(0.0795, 9.94);\n    if (rnd(1)) {\n      this.vibratoDepth = frnd(0.35);\n      this.vibratoRate = frnd(24.8);\n    }\n  }\n  this.attack = 0;\n  this.sustain = frnd(0.363);\n  this.decay = rndr(0.023, 0.57);\n\n  return this;\n};\n\nKnobs.prototype.hitHurt = function () {\n  this.shape = rnd(2);\n  if (this.shape === SINE)\n    this.shape = NOISE;\n  if (this.shape === SQUARE)\n    this.dutyCycle = rndr(0.2, 0.5);\n  if (this.shape === SAWTOOTH)\n    this.dutyCycle = 0;\n  this.frequency = rndr(145, 2261);\n  this.frequencySlide = rndr(-17.2, -217.9);\n  this.attack = 0;\n  this.sustain = frnd(0.023);\n  this.decay = rndr(0.023, 0.2);\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n  return this;\n};\n\nKnobs.prototype.jump = function () {\n  this.shape = SQUARE;\n  this.dutyCycle = rndr(0.2, 0.5);\n  this.frequency = rndr(321, 1274);\n  this.frequencySlide = rndr(0.64, 17.2);\n  this.attack = 0;\n  this.sustain = rndr(0.023, 0.36);\n  this.decay = rndr(0.023, 0.2);\n  if (rnd(1))\n    this.highPassFrequency = frnd(3204);\n  if (rnd(1))\n    this.lowPassFrequency = rndr(2272, 44100);\n  return this;\n};\n\n\nKnobs.prototype.blipSelect = function () {\n  this.shape = rnd(1);\n  if (this.shape === SQUARE)\n    this.dutyCycle = rndr(0.2, 0.5);\n  else\n    this.dutyCycle = 0;\n  this.frequency = rndr(145, 1274);\n  this.attack = 0;\n  this.sustain = rndr(0.023, 0.09);\n  this.decay = frnd(0.09);\n  this.highPassFrequency = 353;\n  return this;\n};\n\nKnobs.prototype.random = function () {\n  if (rnd(1))\n    this.frequency = rndr(885.5, 7941.5);\n  else\n    this.frequency = rndr(3.5, 3532);\n  this.frequencySlide = rndr(-633, 639);\n  if (this.frequency > 1732 && this.frequencySlide > 5)\n    this.frequencySlide = -this.frequencySlide;\n  if (this.frequency < 145 && this.frequencySlide < -0.088)\n    this.frequencySlide = -this.frequencySlide;\n  this.frequencySlideSlide = rndr(-0.88, 0.88);\n  this.dutyCycle = frnd(1);\n  this.dudyCycleSweep = rndr(-17.64, 17.64);\n  this.vibratoDepth = rndr(-0.5, 0.5);\n  this.vibratoRate = rndr(0, 69);\n  this.attack = cube(frnd(1)) * 2.26;\n  this.sustain = sqr(frnd(1)) * 2.26 + 0.09;\n  this.decay = frnd(1) * 2.26;\n  this.punch = sqr(frnd(1)) * 0.64;\n  if (this.attack + this.sustain + this.decay < 0.45) {\n    this.sustain += rndr(0.5, 1.25);\n    this.decay += rndr(0.5, 1.25);\n  }\n  this.lowPassResonance = rndr(0.444, 0.97);\n  this.lowPassFrequency = frnd(39200);\n  this.lowPassSweep = rndr(0.012, 82);\n  if (this.lowPassFrequency < 35 && this.lowPassSweep < 0.802)\n    this.lowPassSweep = 1 - this.lowPassSweep;\n  this.highPassFrequency = 39200 * pow(frnd(1), 5);\n  this.highPassSweep = 555718 * pow(rndr(-1, 1), 5);\n  this.flangerOffset = 0.023 * cube(frnd(2) - 1);\n  this.flangerSweep = cube(frnd(2) - 1);\n  this.retriggerRate = frnd(1378);\n  this.arpeggioDelay = frnd(1.81);\n  this.arpeggioFactor = rndr(0.09, 10);\n  return this;\n};\n\nKnobs.prototype.tone = function () {\n  this.shape = SINE;\n  this.frequency = 440;\n  this.attack = 0;\n  this.sustain = 1;\n  this.decay = 0;\n  return this;\n};\n\nvar genners = 'pickupCoin,laserShoot,explosion,powerUp,hitHurt,jump,blipSelect,random,tone'.split(',');\nfor (var i = 0; i < genners.length; ++i) {\n  (function (g) {\n    if (!Knobs.prototype[g])\n      Knobs.prototype[g] = function () {\n        return this.translate(new Params()[g]());\n      }\n  })(genners[i]);\n}\n\n\nSoundEffect.prototype.init = function (ps) {\n  //\n  // Convert user-facing parameter values to units usable by the sound\n  // generator\n  //\n\n  this.initForRepeat = function() {\n    this.elapsedSinceRepeat = 0;\n\n    this.period = OVERSAMPLING * 44100 / ps.frequency;\n    this.periodMax = OVERSAMPLING * 44100 / ps.frequencyMin;\n    this.enableFrequencyCutoff = (ps.frequencyMin > 0);\n    this.periodMult = Math.pow(.5, ps.frequencySlide / 44100);\n    this.periodMultSlide = ps.frequencySlideSlide * Math.pow(2, -44101/44100)\n      / 44100;\n\n    this.dutyCycle = ps.dutyCycle;\n    this.dutyCycleSlide = ps.dutyCycleSweep / (OVERSAMPLING * 44100);\n\n    this.arpeggioMultiplier = 1 / ps.arpeggioFactor;\n    this.arpeggioTime = ps.arpeggioDelay * 44100;\n  }\n  this.initForRepeat();  // First time through, this is a bit of a misnomer\n\n  // Waveform shape\n  this.waveShape = ps.shape;\n\n  // Low pass filter\n  this.fltw = ps.lowPassFrequency / (OVERSAMPLING * 44100 + ps.lowPassFrequency);\n  this.enableLowPassFilter = ps.lowPassFrequency < 44100;\n  this.fltw_d = Math.pow(ps.lowPassSweep, 1/44100);\n  this.fltdmp = (1 - ps.lowPassResonance) * 9 * (.01 + this.fltw);\n\n  // High pass filter\n  this.flthp = ps.highPassFrequency / (OVERSAMPLING * 44100 + ps.highPassFrequency);\n  this.flthp_d = Math.pow(ps.highPassSweep, 1/44100);\n\n  // Vibrato\n  this.vibratoSpeed = ps.vibratoRate * 64 / 44100 / 10;\n  this.vibratoAmplitude = ps.vibratoDepth;\n\n  // Envelope\n  this.envelopeLength = [\n    Math.floor(ps.attack * 44100),\n    Math.floor(ps.sustain * 44100),\n    Math.floor(ps.decay * 44100)\n  ];\n  this.envelopePunch = ps.punch;\n\n  // Flanger\n  this.flangerOffset = ps.flangerOffset * 44100;\n  this.flangerOffsetSlide = ps.flangerSweep;\n\n  // Repeat\n  this.repeatTime = ps.retriggerRate ? 1 / (44100 * ps.retriggerRate) : 0;\n\n  // Gain\n  this.gain = Math.sqrt(Math.pow(10, ps.gain/10));\n\n  this.sampleRate = ps.sampleRate;\n  this.bitsPerChannel = ps.sampleSize;\n};\n\n\n// This is the function that converts a float to a uint8 or int16\n// cut from the bottom of `generate`\nfunction() {\n      if (this.bitsPerChannel === 8) {\n      // Rescale [-1, 1) to [0, 256)\n      sample = Math.floor((sample + 1) * 128);\n      if (sample > 255) {\n        sample = 255;\n        ++num_clipped;\n      } else if (sample < 0) {\n        sample = 0;\n        ++num_clipped;\n      }\n      buffer.push(sample);\n    } else {\n      // Rescale [-1, 1) to [-32768, 32768)\n      sample = Math.floor(sample * (1<<15));\n      if (sample >= (1<<15)) {\n        sample = (1 << 15)-1;\n        ++num_clipped;\n      } else if (sample < -(1<<15)) {\n        sample = -(1 << 15);\n        ++num_clipped;\n      }\n      buffer.push(sample & 0xFF);\n      buffer.push((sample >> 8) & 0xFF);\n    }\n}\n\n// Create a wav from a uint8 or int16\n// also cut from the bottom of `generate`\nfunction() {\n    var wave = new RIFFWAVE();\n    wave.header.sampleRate = this.sampleRate;\n    wave.header.bitsPerSample = this.bitsPerChannel;\n    wave.Make(buffer);\n    wave.clipping = num_clipped;\n    return wave;\n}",
      "type": "blob"
    },
    "main": {
      "path": "main",
      "content": "(function() {\n  var ApplicationTemplate, Params, Serializer, SoundEffect, audioContext, createAndPlay, params;\n\n  ApplicationTemplate = require(\"./templates/application\");\n\n  Params = require(\"./params\");\n\n  SoundEffect = require(\"./sfx\");\n\n  Serializer = require(\"./serializer\");\n\n  params = new Params;\n\n  audioContext = new AudioContext;\n\n  createAndPlay = function(type) {\n    var audioBuffer, buf, dat, node;\n    params = new Params;\n    params[type]();\n    audioBuffer = SoundEffect(params, audioContext);\n    node = new AudioBufferSourceNode(audioContext, {\n      buffer: audioBuffer\n    });\n    node.connect(audioContext.destination);\n    node.start();\n    dat = JSON.stringify(params);\n    console.log(dat.length, dat);\n    buf = Serializer.serialize(params);\n    return console.log(new Uint8Array(buf));\n  };\n\n  document.body.appendChild(ApplicationTemplate({\n    coin: function() {\n      return createAndPlay(\"pickupCoin\");\n    },\n    laser: function() {\n      return createAndPlay(\"laserShoot\");\n    },\n    explosion: function() {\n      return createAndPlay(\"explosion\");\n    },\n    powerUp: function() {\n      return createAndPlay(\"powerUp\");\n    },\n    hit: function() {\n      return createAndPlay(\"hitHurt\");\n    },\n    jump: function() {\n      return createAndPlay(\"jump\");\n    },\n    blip: function() {\n      return createAndPlay(\"blipSelect\");\n    },\n    tone: function() {\n      return createAndPlay(\"tone\");\n    }\n  }));\n\n}).call(this);\n",
      "type": "blob"
    },
    "templates/application": {
      "path": "templates/application",
      "content": "module.exports = function(data) {\n  \"use strict\";\n  return (function() {\n    var __root;\n    __root = require(\"/lib/jadelet-runtime\")(this);\n    __root.buffer(__root.element(\"application\", this, {}, function(__root) {\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.coin\n      }, function(__root) {\n        __root.buffer(\"Coin\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.laser\n      }, function(__root) {\n        __root.buffer(\"Laser\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.explosion\n      }, function(__root) {\n        __root.buffer(\"Explosion\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.powerUp\n      }, function(__root) {\n        __root.buffer(\"Power Up\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.hit\n      }, function(__root) {\n        __root.buffer(\"Hit\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.jump\n      }, function(__root) {\n        __root.buffer(\"Jump\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.blip\n      }, function(__root) {\n        __root.buffer(\"Blip\\n\");\n      }));\n      __root.buffer(__root.element(\"button\", this, {\n        \"click\": this.tone\n      }, function(__root) {\n        __root.buffer(\"Tone\\n\");\n      }));\n    }));\n    return __root.root;\n  }).call(data);\n};\n",
      "type": "blob"
    },
    "test/params": {
      "path": "test/params",
      "content": "(function() {\n  var Params;\n\n  Params = require(\"../sfxr\").Params;\n\n  describe(\"params\", function() {\n    return it(\"should exist\", function() {\n      var params;\n      params = new Params;\n      return assert(params);\n    });\n  });\n\n}).call(this);\n",
      "type": "blob"
    },
    "sfx": {
      "path": "sfx",
      "content": "module.exports = function(ps, audioContext) {\n  //\n  // Convert user-facing parameter values to units usable by the sound\n  // generator\n  //\n  var m = Math;\n  var floor = m.floor,\n    pow = m.pow,\n    abs = m.abs,\n    random = m.random;\n\n  var SQUARE = 0,\n    SAWTOOTH = 1,\n    SINE = 2,\n    NOISE = 3,\n    OVERSAMPLING = 8,\n    sampleRate = 44100;\n  \n  var i,\n    elapsedSinceRepeat, \n    period,\n    periodMax,\n    enableFrequencyCutoff,\n    periodMult,\n    periodMultSlide,\n    dutyCycle,\n    dutyCycleSlide,\n    arpeggioMultiplier,\n    arpeggioTime;\n\n  function initForRepeat() {\n    elapsedSinceRepeat = 0;\n\n    period = 100 / (ps.p_base_freq * ps.p_base_freq + 0.001);\n    periodMax = 100 / (ps.p_freq_limit * ps.p_freq_limit + 0.001);\n    enableFrequencyCutoff = (ps.p_freq_limit > 0);\n    periodMult = 1 - pow(ps.p_freq_ramp, 3) * 0.01;\n    periodMultSlide = -pow(ps.p_freq_dramp, 3) * 0.000001;\n\n    dutyCycle = 0.5 - ps.p_duty * 0.5;\n    dutyCycleSlide = -ps.p_duty_ramp * 0.00005;\n\n    if (ps.p_arp_mod >= 0)\n      arpeggioMultiplier = 1 - pow(ps.p_arp_mod, 2) * 0.9;\n    else\n      arpeggioMultiplier = 1 + pow(ps.p_arp_mod, 2) * 10;\n    arpeggioTime = floor(pow(1 - ps.p_arp_speed, 2) * 20000 + 32);\n    if (ps.p_arp_speed === 1)\n      arpeggioTime = 0;\n  }\n\n  initForRepeat();\n\n  // Waveform shape\n  var waveShape = parseInt(ps.wave_type);\n\n  // Filter\n  var fltw = pow(ps.p_lpf_freq, 3) * 0.1;\n  var enableLowPassFilter = (ps.p_lpf_freq != 1);\n  var fltw_d = 1 + ps.p_lpf_ramp * 0.0001;\n  var fltdmp = 5 / (1 + pow(ps.p_lpf_resonance, 2) * 20) * (0.01 + fltw);\n  if (fltdmp > 0.8)\n    fltdmp=0.8;\n  var flthp = pow(ps.p_hpf_freq, 2) * 0.1;\n  var flthp_d = 1 + ps.p_hpf_ramp * 0.0003;\n\n  // Vibrato\n  var vibratoSpeed = pow(ps.p_vib_speed, 2) * 0.01;\n  var vibratoAmplitude = ps.p_vib_strength * 0.5;\n\n  // Envelope\n  var envelopeLength = [\n    floor(ps.p_env_attack * ps.p_env_attack * 100000),\n    floor(ps.p_env_sustain * ps.p_env_sustain * 100000),\n    floor(ps.p_env_decay * ps.p_env_decay * 100000)\n  ];\n  var envelopePunch = ps.p_env_punch;\n\n  // Flanger\n  var flangerOffset = pow(ps.p_pha_offset, 2) * 1020;\n  if (ps.p_pha_offset < 0) \n    flangerOffset = -flangerOffset;\n  var flangerOffsetSlide = pow(ps.p_pha_ramp, 2) * 1;\n  if (ps.p_pha_ramp < 0) \n    flangerOffsetSlide = -flangerOffsetSlide;\n\n  // Repeat\n  var repeatTime = floor(pow(1 - ps.p_repeat_speed, 2) * 20000 + 32);\n  if (ps.p_repeat_speed === 0)\n    repeatTime = 0;\n\n  var gain = pow(2, ps.sound_vol) - 1;\n\n  var fltp = 0;\n  var fltdp = 0;\n  var fltphp = 0;\n\n  // TODO: Deterministic output! Don't randomize noise buffer here\n  var noise_buffer = [];\n  for (i = 0; i < 32; ++i)\n    noise_buffer[i] = random() * 2 - 1;\n\n  var envelopeStage = 0;\n  var envelopeElapsed = 0;\n\n  var vibratoPhase = 0;\n\n  var phase = 0;\n  var ipp = 0;\n  var flanger_buffer = [];\n  for (i = 0; i < 1024; ++i)\n    flanger_buffer[i] = 0;\n\n  var num_clipped = 0;\n\n  var buffer = [];\n\n  for(var t = 0; ; ++t) {\n\n    // Repeats\n    if (repeatTime !== 0 && ++elapsedSinceRepeat >= repeatTime)\n      initForRepeat();\n\n    // Arpeggio (single)\n    if(arpeggioTime !== 0 && t >= arpeggioTime) {\n      arpeggioTime = 0;\n      period *= arpeggioMultiplier;\n    }\n\n    // Frequency slide, and frequency slide slide!\n    periodMult += periodMultSlide;\n    period *= periodMult;\n    if(period > periodMax) {\n      period = periodMax;\n      if (enableFrequencyCutoff)\n        break;\n    }\n\n    // Vibrato\n    var rfperiod = period;\n    if (vibratoAmplitude > 0) {\n      vibratoPhase += vibratoSpeed;\n      rfperiod = period * (1 + m.sin(vibratoPhase) * vibratoAmplitude);\n    }\n    var iperiod = floor(rfperiod);\n    if (iperiod < OVERSAMPLING) \n      iperiod = OVERSAMPLING;\n\n    // Square wave duty cycle\n    dutyCycle += dutyCycleSlide;\n    if (dutyCycle < 0) \n      dutyCycle = 0;\n    if (dutyCycle > 0.5) \n      dutyCycle = 0.5;\n\n    // Volume envelope\n    if (++envelopeElapsed > envelopeLength[envelopeStage]) {\n      envelopeElapsed = 0;\n      if (++envelopeStage > 2)\n        break;\n    }\n    var env_vol;\n    var envf = envelopeElapsed / envelopeLength[envelopeStage];\n    if (envelopeStage === 0) {         // Attack\n      env_vol = envf;\n    } else if (envelopeStage === 1) {  // Sustain\n      env_vol = 1 + (1 - envf) * 2 * envelopePunch;\n    } else {                           // Decay\n      env_vol = 1 - envf;\n    }\n\n    // Flanger step\n    flangerOffset += flangerOffsetSlide;\n    var iphase = abs(floor(flangerOffset));\n    if (iphase > 1023) \n      iphase = 1023;\n\n    if (flthp_d !== 0) {\n      flthp *= flthp_d;\n      if (flthp < 0.00001)\n        flthp = 0.00001;\n      if (flthp > 0.1)\n        flthp = 0.1;\n    }\n\n    // 8x oversampling\n    var sample = 0;\n    for (var si = 0; si < OVERSAMPLING; ++si) {\n      var sub_sample = 0;\n      phase++;\n      if (phase >= iperiod) {\n        phase %= iperiod;\n        if (waveShape === NOISE)\n          for(var i = 0; i < 32; ++i)\n            noise_buffer[i] = random() * 2 - 1;\n      }\n\n      // Base waveform\n      var fp = phase / iperiod;\n      if (waveShape === SQUARE) {\n        if (fp < dutyCycle)\n          sub_sample=0.5;\n        else\n          sub_sample=-0.5;\n      } else if (waveShape === SAWTOOTH) {\n        if (fp < dutyCycle)\n          sub_sample = -1 + 2 * fp/dutyCycle;\n        else\n          sub_sample = 1 - 2 * (fp-dutyCycle)/(1-dutyCycle);\n      } else if (waveShape === SINE) {\n        sub_sample = m.sin(fp * 2 * m.PI);\n      } else if (waveShape === NOISE) {\n        sub_sample = noise_buffer[floor(phase * 32 / iperiod)];\n      } else {\n        throw \"ERROR: Bad wave type: \" + waveShape;\n      }\n\n      // Low-pass filter\n      var pp = fltp;\n      fltw *= fltw_d;\n      if (fltw < 0)\n        fltw = 0;\n      if (fltw > 0.1)\n        fltw = 0.1;\n      if (enableLowPassFilter) {\n        fltdp += (sub_sample - fltp) * fltw;\n        fltdp -= fltdp * fltdmp;\n      } else {\n        fltp = sub_sample;\n        fltdp = 0;\n      }\n      fltp += fltdp;\n\n      // High-pass filter\n      fltphp += fltp - pp;\n      fltphp -= fltphp * flthp;\n      sub_sample = fltphp;\n\n      // Flanger\n      flanger_buffer[ipp & 1023] = sub_sample;\n      sub_sample += flanger_buffer[(ipp - iphase + 1024) & 1023];\n      ipp = (ipp + 1) & 1023;\n\n      // final accumulation and envelope application\n      sample += sub_sample * env_vol;\n    }\n\n    sample = sample / OVERSAMPLING;\n    sample *= gain;\n\n    buffer.push(sample);\n  }\n\n  var float32Array = new Float32Array(buffer);\n\n  // Create buffer\n  var audioBuffer = audioContext.createBuffer(1, float32Array.length, sampleRate);\n  var channelData = audioBuffer.getChannelData(0);\n  channelData.set(float32Array);\n\n  return audioBuffer;\n};\n",
      "type": "blob"
    },
    "params": {
      "path": "params",
      "content": "var SQUARE = 0,\n  SAWTOOTH = 1,\n  SINE = 2,\n  NOISE = 3;\n\nfunction sqr(x) { return x * x }\nfunction cube(x) { return x * x * x }\nfunction sign(x) { return x < 0 ? -1 : 1 }\nfunction log(x, b) { return Math.log(x) / Math.log(b); }\nvar pow = Math.pow;\n\n// Sound generation parameters are on [0,1] unless noted SIGNED & thus\n// on [-1,1]\nfunction Params() {\n  // Wave shape\n  this.wave_type = SQUARE;\n\n  // Envelope\n  this.p_env_attack = 0;   // Attack time\n  this.p_env_sustain = 0.3;  // Sustain time\n  this.p_env_punch = 0;    // Sustain punch\n  this.p_env_decay = 0.4;    // Decay time\n\n  // Tone\n  this.p_base_freq = 0.3;    // Start frequency\n  this.p_freq_limit = 0;   // Min frequency cutoff\n  this.p_freq_ramp = 0;    // Slide (SIGNED)\n  this.p_freq_dramp = 0;   // Delta slide (SIGNED)\n  // Vibrato\n  this.p_vib_strength = 0; // Vibrato depth\n  this.p_vib_speed = 0;    // Vibrato speed\n\n  // Tonal change\n  this.p_arp_mod = 0;      // Change amount (SIGNED)\n  this.p_arp_speed = 0;    // Change speed\n\n  // Square wave duty (proportion of time signal is high vs. low)\n  this.p_duty = 0;         // Square duty\n  this.p_duty_ramp = 0;    // Duty sweep (SIGNED)\n\n  // Repeat\n  this.p_repeat_speed = 0; // Repeat speed\n\n  // Flanger\n  this.p_pha_offset = 0;   // Flanger offset (SIGNED)\n  this.p_pha_ramp = 0;     // Flanger sweep (SIGNED)\n\n  // Low-pass filter\n  this.p_lpf_freq = 1;     // Low-pass filter cutoff\n  this.p_lpf_ramp = 0;     // Low-pass filter cutoff sweep (SIGNED)\n  this.p_lpf_resonance = 0;// Low-pass filter resonance\n  // High-pass filter\n  this.p_hpf_freq = 0;     // High-pass filter cutoff\n  this.p_hpf_ramp = 0;     // High-pass filter cutoff sweep (SIGNED)\n\n  // Sample parameters\n  this.sound_vol = 0.5;\n}\n\n\nfunction frnd(range) {\n  return Math.random() * range;\n}\n\nfunction rndr(from, to) {\n  return Math.random() * (to - from) + from;\n}\n\nfunction rnd(max) {\n  return Math.floor(Math.random() * (max + 1));\n}\n\n\n// These functions roll up random sounds appropriate to various\n// typical game events:\n\n\nParams.prototype.pickupCoin = function () {\n  this.p_base_freq = 0.4 + frnd(0.5);\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.1);\n  this.p_env_decay = 0.1 + frnd(0.4);\n  this.p_env_punch = 0.3 + frnd(0.3);\n  if (rnd(1)) {\n    this.p_arp_speed = 0.5 + frnd(0.2);\n    this.p_arp_mod = 0.2 + frnd(0.4);\n  }\n  return this;\n};\n\n\nParams.prototype.laserShoot = function () {\n  this.wave_type = rnd(2);\n  if(this.wave_type === SINE && rnd(1))\n    this.wave_type = rnd(1);\n  if (rnd(2) === 0) {\n    this.p_base_freq = 0.3 + frnd(0.6);\n    this.p_freq_limit = frnd(0.1);\n    this.p_freq_ramp = -0.35 - frnd(0.3);\n  } else {\n    this.p_base_freq = 0.5 + frnd(0.5);\n    this.p_freq_limit = this.p_base_freq - 0.2 - frnd(0.6);\n    if (this.p_freq_limit < 0.2) this.p_freq_limit = 0.2;\n    this.p_freq_ramp = -0.15 - frnd(0.2);\n  }\n  if (this.wave_type === SAWTOOTH)\n    this.p_duty = 1;\n  if (rnd(1)) {\n    this.p_duty = frnd(0.5);\n    this.p_duty_ramp = frnd(0.2);\n  } else {\n    this.p_duty = 0.4 + frnd(0.5);\n    this.p_duty_ramp = -frnd(0.7);\n  }\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.2);\n  this.p_env_decay = frnd(0.4);\n  if (rnd(1))\n    this.p_env_punch = frnd(0.3);\n  if (rnd(2) === 0) {\n    this.p_pha_offset = frnd(0.2);\n    this.p_pha_ramp = -frnd(0.2);\n  }\n  //if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n\n  return this;\n};\n\n\nParams.prototype.explosion = function () {\n  this.wave_type = NOISE;\n  if (rnd(1)) {\n    this.p_base_freq = sqr(0.1 + frnd(0.4));\n    this.p_freq_ramp = -0.1 + frnd(0.4);\n  } else {\n    this.p_base_freq = sqr(0.2 + frnd(0.7));\n    this.p_freq_ramp = -0.2 - frnd(0.2);\n  }\n  if (rnd(4) === 0)\n    this.p_freq_ramp = 0;\n  if (rnd(2) === 0)\n    this.p_repeat_speed = 0.3 + frnd(0.5);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.3);\n  this.p_env_decay = frnd(0.5);\n  if (rnd(1)) {\n    this.p_pha_offset = -0.3 + frnd(0.9);\n    this.p_pha_ramp = -frnd(0.3);\n  }\n  this.p_env_punch = 0.2 + frnd(0.6);\n  if (rnd(1)) {\n    this.p_vib_strength = frnd(0.7);\n    this.p_vib_speed = frnd(0.6);\n  }\n  if (rnd(2) === 0) {\n    this.p_arp_speed = 0.6 + frnd(0.3);\n    this.p_arp_mod = 0.8 - frnd(1.6);\n  }\n\n  return this;\n};\n\n\nParams.prototype.powerUp = function () {\n  if (rnd(1)) {\n    this.wave_type = SAWTOOTH;\n    this.p_duty = 1;\n  } else {\n    this.p_duty = frnd(0.6);\n  }\n  this.p_base_freq = 0.2 + frnd(0.3);\n  if (rnd(1)) {\n    this.p_freq_ramp = 0.1 + frnd(0.4);\n    this.p_repeat_speed = 0.4 + frnd(0.4);\n  } else {\n    this.p_freq_ramp = 0.05 + frnd(0.2);\n    if (rnd(1)) {\n      this.p_vib_strength = frnd(0.7);\n      this.p_vib_speed = frnd(0.6);\n    }\n  }\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.4);\n  this.p_env_decay = 0.1 + frnd(0.4);\n\n  return this;\n};\n\n\nParams.prototype.hitHurt = function () {\n  this.wave_type = rnd(2);\n  if (this.wave_type === SINE)\n    this.wave_type = NOISE;\n  if (this.wave_type === SQUARE)\n    this.p_duty = frnd(0.6);\n  if (this.wave_type === SAWTOOTH)\n    this.p_duty = 1;\n  this.p_base_freq = 0.2 + frnd(0.6);\n  this.p_freq_ramp = -0.3 - frnd(0.4);\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.1);\n  this.p_env_decay = 0.1 + frnd(0.2);\n  if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n  return this;\n};\n\n\nParams.prototype.jump = function () {\n  this.wave_type = SQUARE;\n  this.p_duty = frnd(0.6);\n  this.p_base_freq = 0.3 + frnd(0.3);\n  this.p_freq_ramp = 0.1 + frnd(0.2);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.3);\n  this.p_env_decay = 0.1 + frnd(0.2);\n  if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n  if (rnd(1))\n    this.p_lpf_freq = 1 - frnd(0.6);\n  return this;\n};\n\n\nParams.prototype.blipSelect = function () {\n  this.wave_type = rnd(1);\n  if (this.wave_type === SQUARE)\n    this.p_duty = frnd(0.6);\n  else\n    this.p_duty = 1;\n  this.p_base_freq = 0.2 + frnd(0.4);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.1);\n  this.p_env_decay = frnd(0.2);\n  this.p_hpf_freq = 0.1;\n  return this;\n};\n\n\nParams.prototype.tone = function () {\n  this.wave_type = SINE;\n  this.p_base_freq = 0.35173364; // 440 Hz\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.6641; // 1 sec\n  this.p_env_decay = 0;\n  this.p_env_punch = 0;\n  return this;\n};\n\n\nParams.prototype.mutate = function () {\n  if (rnd(1)) this.p_base_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_freq_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_freq_dramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_duty += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_duty_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_strength += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_delay += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_attack += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_sustain += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_decay += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_punch += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_resonance += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_hpf_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_hpf_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_pha_offset += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_pha_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_repeat_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_arp_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_arp_mod += frnd(0.1) - 0.05;\n};\n\n\nParams.prototype.random = function () {\n  if (rnd(1))\n    this.p_base_freq = cube(frnd(2) - 1) + 0.5;\n  else\n    this.p_base_freq = sqr(frnd(1));\n  this.p_freq_limit = 0;\n  this.p_freq_ramp = Math.pow(frnd(2) - 1, 5);\n  if (this.p_base_freq > 0.7 && this.p_freq_ramp > 0.2)\n    this.p_freq_ramp = -this.p_freq_ramp;\n  if (this.p_base_freq < 0.2 && this.p_freq_ramp < -0.05)\n    this.p_freq_ramp = -this.p_freq_ramp;\n  this.p_freq_dramp = Math.pow(frnd(2) - 1, 3);\n  this.p_duty = frnd(2) - 1;\n  this.p_duty_ramp = Math.pow(frnd(2) - 1, 3);\n  this.p_vib_strength = Math.pow(frnd(2) - 1, 3);\n  this.p_vib_speed = rndr(-1, 1);\n  this.p_env_attack = cube(rndr(-1, 1));\n  this.p_env_sustain = sqr(rndr(-1, 1));\n  this.p_env_decay = rndr(-1, 1);\n  this.p_env_punch = Math.pow(frnd(0.8), 2);\n  if (this.p_env_attack + this.p_env_sustain + this.p_env_decay < 0.2) {\n    this.p_env_sustain += 0.2 + frnd(0.3);\n    this.p_env_decay += 0.2 + frnd(0.3);\n  }\n  this.p_lpf_resonance = rndr(-1, 1);\n  this.p_lpf_freq = 1 - Math.pow(frnd(1), 3);\n  this.p_lpf_ramp = Math.pow(frnd(2) - 1, 3);\n  if (this.p_lpf_freq < 0.1 && this.p_lpf_ramp < -0.05)\n    this.p_lpf_ramp = -this.p_lpf_ramp;\n  this.p_hpf_freq = Math.pow(frnd(1), 5);\n  this.p_hpf_ramp = Math.pow(frnd(2) - 1, 5);\n  this.p_pha_offset = Math.pow(frnd(2) - 1, 3);\n  this.p_pha_ramp = Math.pow(frnd(2) - 1, 3);\n  this.p_repeat_speed = frnd(2) - 1;\n  this.p_arp_speed = frnd(2) - 1;\n  this.p_arp_mod = frnd(2) - 1;\n  return this;\n};\n\nmodule.exports = Params;\n",
      "type": "blob"
    },
    "lib/riffwave": {
      "path": "lib/riffwave",
      "content": "/*\n * RIFFWAVE.js v0.03 - Audio encoder for HTML5 <audio> elements.\n * Copyright (C) 2011 Pedro Ladaria <pedro.ladaria at Gmail dot com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * version 2 as published by the Free Software Foundation.\n * The full license is available at http://www.gnu.org/licenses/gpl.html\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n *\n * Changelog:\n *\n * 0.01 - First release\n * 0.02 - New faster base64 encoding\n * 0.03 - Blob URLs\n *\n */\n\nvar RIFFWAVE = function(data) {\n\n  this.data = [];        // Byte array containing audio samples\n  this.wav = [];         // Array containing the generated wave file\n  this.dataURI = '';     // http://en.wikipedia.org/wiki/Data_URI_scheme\n\n  this.header = {                         // OFFS SIZE NOTES\n    chunkId      : [0x52,0x49,0x46,0x46], // 0    4    \"RIFF\" = 0x52494646\n    chunkSize    : 0,                     // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)\n    format       : [0x57,0x41,0x56,0x45], // 8    4    \"WAVE\" = 0x57415645\n    subChunk1Id  : [0x66,0x6d,0x74,0x20], // 12   4    \"fmt \" = 0x666d7420\n    subChunk1Size: 16,                    // 16   4    16 for PCM\n    audioFormat  : 1,                     // 20   2    PCM = 1\n    numChannels  : 1,                     // 22   2    Mono = 1, Stereo = 2, etc.\n    sampleRate   : 8000,                  // 24   4    8000, 44100, etc\n    byteRate     : 0,                     // 28   4    SampleRate*NumChannels*BitsPerSample/8\n    blockAlign   : 0,                     // 32   2    NumChannels*BitsPerSample/8\n    bitsPerSample: 8,                     // 34   2    8 bits = 8, 16 bits = 16, etc...\n    subChunk2Id  : [0x64,0x61,0x74,0x61], // 36   4    \"data\" = 0x64617461\n    subChunk2Size: 0                      // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8\n  };\n\n  function u32ToArray(i) { return [i&0xFF, (i>>8)&0xFF, (i>>16)&0xFF, (i>>24)&0xFF]; }\n\n  function u16ToArray(i) { return [i&0xFF, (i>>8)&0xFF]; }\n\n  this.Make = function(data) {\n    if (data instanceof Array) this.data = data;\n    this.header.byteRate = (this.header.sampleRate * this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.blockAlign = (this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.subChunk2Size = this.data.length;\n    this.header.chunkSize = 36 + this.header.subChunk2Size;\n\n    this.wav = this.header.chunkId.concat(\n      u32ToArray(this.header.chunkSize),\n      this.header.format,\n      this.header.subChunk1Id,\n      u32ToArray(this.header.subChunk1Size),\n      u16ToArray(this.header.audioFormat),\n      u16ToArray(this.header.numChannels),\n      u32ToArray(this.header.sampleRate),\n      u32ToArray(this.header.byteRate),\n      u16ToArray(this.header.blockAlign),\n      u16ToArray(this.header.bitsPerSample),\n      this.header.subChunk2Id,\n      u32ToArray(this.header.subChunk2Size),\n      this.data\n    );\n\n    var dat = Uint8Array.from(this.wav);\n    var blob = new Blob([dat], {type: \"audio/wav\"});\n    var url = URL.createObjectURL(blob);\n    this.dataURI = url;\n  };\n\n  if (data instanceof Array) this.Make(data);\n\n}; // end RIFFWAVE\n\n\nif (typeof exports != 'undefined')  // For node.js\n  exports.RIFFWAVE = RIFFWAVE;\n",
      "type": "blob"
    },
    "serializer": {
      "path": "serializer",
      "content": "(function() {\n  module.exports = {\n    serialize: function(params) {\n      var buffer, dataView;\n      buffer = new ArrayBuffer(100);\n      dataView = new DataView(buffer);\n      Object.keys(params).forEach(function(key, i) {\n        var param;\n        param = params[key];\n        if (i === 0) {\n          \"fxz\".split(\"\").forEach(function(s, n) {\n            return dataView.setUint8(n, s.charCodeAt(0));\n          });\n          dataView.setUint8(3, 1);\n          return dataView.setUint8(4, param);\n        } else {\n          return dataView.setFloat32((i + 1) * 4, param, true);\n        }\n      });\n      return buffer;\n    },\n    deserialize: function(arrayBuffer, params) {\n      var buffer, dataView;\n      buffer = new ArrayBuffer(100);\n      dataView = new DataView(buffer);\n      Object.keys(params).forEach(function(key, i) {\n        var version;\n        if (i === 0) {\n          \"fxz\".split(\"\").forEach(function(s, n) {\n            var charCode;\n            charCode = s.charCodeAt(0);\n            if (charCode !== dataView.getUint8(n)) {\n              throw new Error(\"Unknown file format: expected '\" + s + \"' (\" + charCode + \") at byte \" + n);\n            }\n          });\n          version = dataView.getUint8(3);\n          if (version !== 1) {\n            throw new Error(\"Unknown version '\" + version + \"': expected 1\");\n          }\n          return params[key] = dataView.getUint8(4);\n        } else {\n          return params[key] = dataView.getFloat32((i + 1) * 4, true);\n        }\n      });\n      return params;\n    }\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "lib/jadelet-runtime": {
      "path": "lib/jadelet-runtime",
      "content": "!function(n){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=n();else if(\"function\"==typeof define&&define.amd)define([],n);else{(\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:this).JadeletRuntime=n()}}(function(){return function n(e,t,r){function o(i,c){if(!t[i]){if(!e[i]){var f=\"function\"==typeof require&&require;if(!c&&f)return f(i,!0);if(u)return u(i,!0);var l=new Error(\"Cannot find module '\"+i+\"'\");throw l.code=\"MODULE_NOT_FOUND\",l}var a=t[i]={exports:{}};e[i][0].call(a.exports,function(n){var t=e[i][1][n];return o(t||n)},a,a.exports,n,e,t,r)}return t[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<r.length;i++)o(r[i]);return o}({1:[function(n,e,t){(function(){\"use strict\";var t,r,o,u,i,c,f,l,a,s,d,p,v,h,g,y,b,m,E,O,_,x,w,A,C;t=n(\"o_0\"),a=new WeakMap,s=new WeakMap,_=function(n){var e;e=s.get(n)||0,s.set(n,e+1)},O=function(n){var e;e=s.get(n)||0,--e>0?s.set(n,e):(s.delete(n),l(n))},l=function(n){var e,t;null!=(e=n.children)&&Array.prototype.forEach.call(e,l),null!=(t=a.get(n))&&t.forEach(function(e){e(),a.delete(n)})},o=function(n,e){var t;(t=a.get(n))?t.push(e):a.set(n,[e])},p=/^on(touch|animation|transition)(start|iteration|move|end|cancel)$/,h=function(n,e){return n.match(p)||n in e},A=function(n,e,t){switch(n.nodeName){case\"SELECT\":n.oninput=n.onchange=function(){var n,t,r;n=(t=this.children[this.selectedIndex]).value,r=t._value,\"function\"==typeof e&&e(r||n)},i(n,e,t,function(e){var t;n._value=e,(t=n._options)?null!=e.value?n.value=(\"function\"==typeof e.value?e.value():void 0)||e.value:n.selectedIndex=C(t,e):n.value=e});break;default:n.oninput=n.onchange=function(){\"function\"==typeof e&&e(n.value)},i(n,e,t,function(e){n.value!==e&&(n.value=e)})}},x={INPUT:{checked:function(n,e,t){return n.onchange=function(){\"function\"==typeof e&&e(n.checked)},i(n,e,t,function(e){n.checked=e})}},SELECT:{options:function(n,e,t){i(n,e,t,function(e){d(n),n._options=e,e.map(function(e,t){var r,o,u;return r=f(\"option\"),r._value=e,u=g(e)?(null!=e?e.value:void 0)||t:e.toString(),i(r,u,e,function(n){r.value=n}),o=(null!=e?e.name:void 0)||e,i(r,o,e,function(n){r.textContent=n}),n.appendChild(r),e===n._value&&(n.selectedIndex=t),r})})}}},b=function(n,e,t,r){var o,c,f;c=n.nodeName,\"value\"===t?A(n,r):(o=null!=(f=x[c])?f[t]:void 0)?o(n,r,e):t.match(/^on/)&&h(t,n)?u(n,t.substr(2),r,e):h(\"on\"+t,n)?u(n,t,r,e):i(n,r,e,function(e){null!=e&&!1!==e?n.setAttribute(t,e):n.removeAttribute(t)})},m=function(n,e,t){c(n,e,t,\"id\",function(e){var t;t=e[e.length-1],e.length?n.id=t:n.removeAttribute(\"id\")}),c(n,e,t,\"class\",function(e){n.className=e.join(\" \")}),c(n,e,t,\"style\",function(e){n.removeAttribute(\"style\"),e.forEach(function(e){return g(e)?Object.assign(n.style,e):n.setAttribute(\"style\",e)})}),Object.keys(t).forEach(function(r){b(n,e,r,t[r])})},i=function(n,e,r,u){var i;i=t(function(){u(v(e,r))}),o(n,i.releaseDependencies)},u=function(n,e,t,r){\"function\"==typeof t&&n.addEventListener(e,t.bind(r))},c=function(n,e,t,r,o){var u;null!=(u=t[r])&&(delete t[r],i(n,function(){return w(u,e)},e,o))},E=function(n,e,t){var r;r=function(e){null==e||(\"function\"==typeof e.forEach?e.forEach(r):e instanceof Node?(_(e),n.appendChild(e)):n.appendChild(document.createTextNode(e)))},i(n,function(){var n;return n=[],t.call(e,{buffer:function(t){n.push(v(t,e))},element:y}),n},e,function(e){d(n),e.forEach(r)})},y=function(n,e,t,r){var o;return o=f(n),m(o,e,t),\"SELECT\"!==o.nodeName&&E(o,e,r),o},(r=function(n){var e;return e={buffer:function(n){if(e.root)throw new Error(\"Cannot have multiple root elements\");e.root=n},element:y}}).Observable=t,r._elementCleaners=a,r._dispose=l,r.retain=_,r.release=O,e.exports=r,f=function(n){return document.createElement(n)},d=function(n){for(var e;e=n.firstChild;)n.removeChild(e),O(e)},g=function(n){return\"object\"==typeof n},C=function(n,e){return g(e)?n.indexOf(e):n.map(function(n){return n.toString()}).indexOf(e.toString())},w=function(n,e){return n.map(function(n){return v(n,e)}).reduce(function(n,e){return n.concat(v(e))},[]).filter(function(n){return null!=n})},v=function(n,e){return\"function\"==typeof n?n.call(e):n}}).call(this)},{o_0:2}],2:[function(n,e,t){(function(n){(function(){\"use strict\";var t,r,o,u,i,c,f,l,a=[].slice;e.exports=function(n,e){var u,s,d,p,v;return\"function\"==typeof(null!=n?n.observe:void 0)?n:(d=[],p=function(n){return r(d).forEach(function(e){return e(n)})},\"function\"==typeof n?(s=n,(v=function(){return i(v),n}).releaseDependencies=function(){var n;return null!=(n=v._observableDependencies)?n.forEach(function(n){return n.stopObserving(u)}):void 0},(u=function(){var t;return t=new Set,n=l(t,s,e),v.releaseDependencies(),v._observableDependencies=t,t.forEach(function(n){return n.observe(u)}),p(n)})()):(v=function(e){return arguments.length>0?n!==e&&(n=e,p(e)):i(v),n}).releaseDependencies=c,Array.isArray(n)&&([\"concat\",\"every\",\"filter\",\"forEach\",\"indexOf\",\"join\",\"lastIndexOf\",\"map\",\"reduce\",\"reduceRight\",\"slice\",\"some\"].forEach(function(e){return v[e]=function(){var t;return t=1<=arguments.length?a.call(arguments,0):[],i(v),n[e].apply(n,t)}}),[\"pop\",\"push\",\"reverse\",\"shift\",\"splice\",\"sort\",\"unshift\"].forEach(function(e){return v[e]=function(){var t,r;return t=1<=arguments.length?a.call(arguments,0):[],r=n[e].apply(n,t),p(n),r}}),t&&Object.defineProperty(v,\"length\",{get:function(){return i(v),n.length},set:function(e){var t;return t=n.length=e,p(n),t}}),o(v,{remove:function(e){var t,r;if((t=n.indexOf(e))>=0)return r=n.splice(t,1)[0],p(n),r},get:function(e){return i(v),n[e]},first:function(){return i(v),n[0]},last:function(){return i(v),n[n.length-1]},size:function(){return i(v),n.length}})),o(v,{listeners:d,observe:function(n){return d.push(n)},stopObserving:function(n){return f(d,n)},toggle:function(){return v(!n)},increment:function(e){return null==e&&(e=1),v(n+e)},decrement:function(e){return null==e&&(e=1),v(n-e)},toString:function(){return\"Observable(\"+n+\")\"}}),v)},o=Object.assign,n.OBSERVABLE_ROOT_HACK=[],i=function(e){var t;if(t=u(n.OBSERVABLE_ROOT_HACK))return t.add(e)},l=function(e,t,r){n.OBSERVABLE_ROOT_HACK.push(e);try{return t.call(r)}finally{n.OBSERVABLE_ROOT_HACK.pop()}},f=function(n,e){var t;if((t=n.indexOf(e))>=0)return n.splice(t,1)[0]},r=function(n){return n.concat([])},u=function(n){return n[n.length-1]},c=function(){};try{Object.defineProperty(function(){},\"length\",{get:c,set:c}),t=!0}catch(n){t=!1}}).call(this)}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1])(1)});\n",
      "type": "blob"
    }
  },
  "progenitor": {
    "url": "https://danielx.net/editor/"
  },
  "config": {},
  "entryPoint": "main",
  "repository": {
    "branch": "shifting-around",
    "default_branch": "master",
    "full_name": "STRd6/sfxz",
    "homepage": "http://grumdrig.github.com/jsfxr/",
    "description": "Simple and efficient sound effects generator. A port of sfxr to HTML5.",
    "html_url": "https://github.com/STRd6/sfxz",
    "url": "https://api.github.com/repos/STRd6/sfxz",
    "publishBranch": "gh-pages"
  },
  "dependencies": {}
});